// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package da

import (
	"context"

	"github.com/celestiaorg/go-square/v3/share"
	"github.com/evstack/ev-node/pkg/da/jsonrpc"
	mock "github.com/stretchr/testify/mock"
)

// NewMockBlobAPI creates a new instance of MockBlobAPI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBlobAPI(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBlobAPI {
	mock := &MockBlobAPI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBlobAPI is an autogenerated mock type for the BlobAPI type
type MockBlobAPI struct {
	mock.Mock
}

type MockBlobAPI_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBlobAPI) EXPECT() *MockBlobAPI_Expecter {
	return &MockBlobAPI_Expecter{mock: &_m.Mock}
}

// GetAll provides a mock function for the type MockBlobAPI
func (_mock *MockBlobAPI) GetAll(ctx context.Context, height uint64, namespaces []share.Namespace) ([]*blob.Blob, error) {
	ret := _mock.Called(ctx, height, namespaces)

	if len(ret) == 0 {
		panic("no return value specified for GetAll")
	}

	var r0 []*blob.Blob
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, []share.Namespace) ([]*blob.Blob, error)); ok {
		return returnFunc(ctx, height, namespaces)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, []share.Namespace) []*blob.Blob); ok {
		r0 = returnFunc(ctx, height, namespaces)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*blob.Blob)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, []share.Namespace) error); ok {
		r1 = returnFunc(ctx, height, namespaces)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBlobAPI_GetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAll'
type MockBlobAPI_GetAll_Call struct {
	*mock.Call
}

// GetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - height uint64
//   - namespaces []share.Namespace
func (_e *MockBlobAPI_Expecter) GetAll(ctx interface{}, height interface{}, namespaces interface{}) *MockBlobAPI_GetAll_Call {
	return &MockBlobAPI_GetAll_Call{Call: _e.mock.On("GetAll", ctx, height, namespaces)}
}

func (_c *MockBlobAPI_GetAll_Call) Run(run func(ctx context.Context, height uint64, namespaces []share.Namespace)) *MockBlobAPI_GetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 []share.Namespace
		if args[2] != nil {
			arg2 = args[2].([]share.Namespace)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBlobAPI_GetAll_Call) Return(blobs []*blob.Blob, err error) *MockBlobAPI_GetAll_Call {
	_c.Call.Return(blobs, err)
	return _c
}

func (_c *MockBlobAPI_GetAll_Call) RunAndReturn(run func(ctx context.Context, height uint64, namespaces []share.Namespace) ([]*blob.Blob, error)) *MockBlobAPI_GetAll_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitmentProof provides a mock function for the type MockBlobAPI
func (_mock *MockBlobAPI) GetCommitmentProof(ctx context.Context, height uint64, namespace share.Namespace, shareCommitment []byte) (*blob.CommitmentProof, error) {
	ret := _mock.Called(ctx, height, namespace, shareCommitment)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitmentProof")
	}

	var r0 *blob.CommitmentProof
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, share.Namespace, []byte) (*blob.CommitmentProof, error)); ok {
		return returnFunc(ctx, height, namespace, shareCommitment)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, share.Namespace, []byte) *blob.CommitmentProof); ok {
		r0 = returnFunc(ctx, height, namespace, shareCommitment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blob.CommitmentProof)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, share.Namespace, []byte) error); ok {
		r1 = returnFunc(ctx, height, namespace, shareCommitment)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBlobAPI_GetCommitmentProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitmentProof'
type MockBlobAPI_GetCommitmentProof_Call struct {
	*mock.Call
}

// GetCommitmentProof is a helper method to define mock.On call
//   - ctx context.Context
//   - height uint64
//   - namespace share.Namespace
//   - shareCommitment []byte
func (_e *MockBlobAPI_Expecter) GetCommitmentProof(ctx interface{}, height interface{}, namespace interface{}, shareCommitment interface{}) *MockBlobAPI_GetCommitmentProof_Call {
	return &MockBlobAPI_GetCommitmentProof_Call{Call: _e.mock.On("GetCommitmentProof", ctx, height, namespace, shareCommitment)}
}

func (_c *MockBlobAPI_GetCommitmentProof_Call) Run(run func(ctx context.Context, height uint64, namespace share.Namespace, shareCommitment []byte)) *MockBlobAPI_GetCommitmentProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 share.Namespace
		if args[2] != nil {
			arg2 = args[2].(share.Namespace)
		}
		var arg3 []byte
		if args[3] != nil {
			arg3 = args[3].([]byte)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockBlobAPI_GetCommitmentProof_Call) Return(commitmentProof *blob.CommitmentProof, err error) *MockBlobAPI_GetCommitmentProof_Call {
	_c.Call.Return(commitmentProof, err)
	return _c
}

func (_c *MockBlobAPI_GetCommitmentProof_Call) RunAndReturn(run func(ctx context.Context, height uint64, namespace share.Namespace, shareCommitment []byte) (*blob.CommitmentProof, error)) *MockBlobAPI_GetCommitmentProof_Call {
	_c.Call.Return(run)
	return _c
}

// GetProof provides a mock function for the type MockBlobAPI
func (_mock *MockBlobAPI) GetProof(ctx context.Context, height uint64, namespace share.Namespace, commitment blob.Commitment) (*blob.Proof, error) {
	ret := _mock.Called(ctx, height, namespace, commitment)

	if len(ret) == 0 {
		panic("no return value specified for GetProof")
	}

	var r0 *blob.Proof
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, share.Namespace, blob.Commitment) (*blob.Proof, error)); ok {
		return returnFunc(ctx, height, namespace, commitment)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, share.Namespace, blob.Commitment) *blob.Proof); ok {
		r0 = returnFunc(ctx, height, namespace, commitment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blob.Proof)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, share.Namespace, blob.Commitment) error); ok {
		r1 = returnFunc(ctx, height, namespace, commitment)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBlobAPI_GetProof_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProof'
type MockBlobAPI_GetProof_Call struct {
	*mock.Call
}

// GetProof is a helper method to define mock.On call
//   - ctx context.Context
//   - height uint64
//   - namespace share.Namespace
//   - commitment blob.Commitment
func (_e *MockBlobAPI_Expecter) GetProof(ctx interface{}, height interface{}, namespace interface{}, commitment interface{}) *MockBlobAPI_GetProof_Call {
	return &MockBlobAPI_GetProof_Call{Call: _e.mock.On("GetProof", ctx, height, namespace, commitment)}
}

func (_c *MockBlobAPI_GetProof_Call) Run(run func(ctx context.Context, height uint64, namespace share.Namespace, commitment blob.Commitment)) *MockBlobAPI_GetProof_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 share.Namespace
		if args[2] != nil {
			arg2 = args[2].(share.Namespace)
		}
		var arg3 blob.Commitment
		if args[3] != nil {
			arg3 = args[3].(blob.Commitment)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockBlobAPI_GetProof_Call) Return(proof *blob.Proof, err error) *MockBlobAPI_GetProof_Call {
	_c.Call.Return(proof, err)
	return _c
}

func (_c *MockBlobAPI_GetProof_Call) RunAndReturn(run func(ctx context.Context, height uint64, namespace share.Namespace, commitment blob.Commitment) (*blob.Proof, error)) *MockBlobAPI_GetProof_Call {
	_c.Call.Return(run)
	return _c
}

// Included provides a mock function for the type MockBlobAPI
func (_mock *MockBlobAPI) Included(ctx context.Context, height uint64, namespace share.Namespace, proof *blob.Proof, commitment blob.Commitment) (bool, error) {
	ret := _mock.Called(ctx, height, namespace, proof, commitment)

	if len(ret) == 0 {
		panic("no return value specified for Included")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, share.Namespace, *blob.Proof, blob.Commitment) (bool, error)); ok {
		return returnFunc(ctx, height, namespace, proof, commitment)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uint64, share.Namespace, *blob.Proof, blob.Commitment) bool); ok {
		r0 = returnFunc(ctx, height, namespace, proof, commitment)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uint64, share.Namespace, *blob.Proof, blob.Commitment) error); ok {
		r1 = returnFunc(ctx, height, namespace, proof, commitment)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBlobAPI_Included_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Included'
type MockBlobAPI_Included_Call struct {
	*mock.Call
}

// Included is a helper method to define mock.On call
//   - ctx context.Context
//   - height uint64
//   - namespace share.Namespace
//   - proof *blob.Proof
//   - commitment blob.Commitment
func (_e *MockBlobAPI_Expecter) Included(ctx interface{}, height interface{}, namespace interface{}, proof interface{}, commitment interface{}) *MockBlobAPI_Included_Call {
	return &MockBlobAPI_Included_Call{Call: _e.mock.On("Included", ctx, height, namespace, proof, commitment)}
}

func (_c *MockBlobAPI_Included_Call) Run(run func(ctx context.Context, height uint64, namespace share.Namespace, proof *blob.Proof, commitment blob.Commitment)) *MockBlobAPI_Included_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uint64
		if args[1] != nil {
			arg1 = args[1].(uint64)
		}
		var arg2 share.Namespace
		if args[2] != nil {
			arg2 = args[2].(share.Namespace)
		}
		var arg3 *blob.Proof
		if args[3] != nil {
			arg3 = args[3].(*blob.Proof)
		}
		var arg4 blob.Commitment
		if args[4] != nil {
			arg4 = args[4].(blob.Commitment)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockBlobAPI_Included_Call) Return(b bool, err error) *MockBlobAPI_Included_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *MockBlobAPI_Included_Call) RunAndReturn(run func(ctx context.Context, height uint64, namespace share.Namespace, proof *blob.Proof, commitment blob.Commitment) (bool, error)) *MockBlobAPI_Included_Call {
	_c.Call.Return(run)
	return _c
}

// Submit provides a mock function for the type MockBlobAPI
func (_mock *MockBlobAPI) Submit(ctx context.Context, blobs []*blob.Blob, opts *blob.SubmitOptions) (uint64, error) {
	ret := _mock.Called(ctx, blobs, opts)

	if len(ret) == 0 {
		panic("no return value specified for Submit")
	}

	var r0 uint64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*blob.Blob, *blob.SubmitOptions) (uint64, error)); ok {
		return returnFunc(ctx, blobs, opts)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []*blob.Blob, *blob.SubmitOptions) uint64); ok {
		r0 = returnFunc(ctx, blobs, opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []*blob.Blob, *blob.SubmitOptions) error); ok {
		r1 = returnFunc(ctx, blobs, opts)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBlobAPI_Submit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Submit'
type MockBlobAPI_Submit_Call struct {
	*mock.Call
}

// Submit is a helper method to define mock.On call
//   - ctx context.Context
//   - blobs []*blob.Blob
//   - opts *blob.SubmitOptions
func (_e *MockBlobAPI_Expecter) Submit(ctx interface{}, blobs interface{}, opts interface{}) *MockBlobAPI_Submit_Call {
	return &MockBlobAPI_Submit_Call{Call: _e.mock.On("Submit", ctx, blobs, opts)}
}

func (_c *MockBlobAPI_Submit_Call) Run(run func(ctx context.Context, blobs []*blob.Blob, opts *blob.SubmitOptions)) *MockBlobAPI_Submit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []*blob.Blob
		if args[1] != nil {
			arg1 = args[1].([]*blob.Blob)
		}
		var arg2 *blob.SubmitOptions
		if args[2] != nil {
			arg2 = args[2].(*blob.SubmitOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBlobAPI_Submit_Call) Return(v uint64, err error) *MockBlobAPI_Submit_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockBlobAPI_Submit_Call) RunAndReturn(run func(ctx context.Context, blobs []*blob.Blob, opts *blob.SubmitOptions) (uint64, error)) *MockBlobAPI_Submit_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function for the type MockBlobAPI
func (_mock *MockBlobAPI) Subscribe(ctx context.Context, namespace share.Namespace) (<-chan *blob.SubscriptionResponse, error) {
	ret := _mock.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 <-chan *blob.SubscriptionResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, share.Namespace) (<-chan *blob.SubscriptionResponse, error)); ok {
		return returnFunc(ctx, namespace)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, share.Namespace) <-chan *blob.SubscriptionResponse); ok {
		r0 = returnFunc(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan *blob.SubscriptionResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, share.Namespace) error); ok {
		r1 = returnFunc(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBlobAPI_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type MockBlobAPI_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace share.Namespace
func (_e *MockBlobAPI_Expecter) Subscribe(ctx interface{}, namespace interface{}) *MockBlobAPI_Subscribe_Call {
	return &MockBlobAPI_Subscribe_Call{Call: _e.mock.On("Subscribe", ctx, namespace)}
}

func (_c *MockBlobAPI_Subscribe_Call) Run(run func(ctx context.Context, namespace share.Namespace)) *MockBlobAPI_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 share.Namespace
		if args[1] != nil {
			arg1 = args[1].(share.Namespace)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBlobAPI_Subscribe_Call) Return(subscriptionResponseCh <-chan *blob.SubscriptionResponse, err error) *MockBlobAPI_Subscribe_Call {
	_c.Call.Return(subscriptionResponseCh, err)
	return _c
}

func (_c *MockBlobAPI_Subscribe_Call) RunAndReturn(run func(ctx context.Context, namespace share.Namespace) (<-chan *blob.SubscriptionResponse, error)) *MockBlobAPI_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}
