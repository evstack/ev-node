<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rollkit Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="specs/template.html"><strong aria-hidden="true">1.</strong> Template</a></li><li class="chapter-item expanded "><a href="specs/rollkit-dependency-graph.html"><strong aria-hidden="true">2.</strong> Dependency Graph</a></li><li class="chapter-item expanded "><a href="specs/block-manager.html"><strong aria-hidden="true">3.</strong> Block Manager</a></li><li class="chapter-item expanded "><a href="specs/block-validity.html"><strong aria-hidden="true">4.</strong> Block Validity</a></li><li class="chapter-item expanded "><a href="specs/da.html"><strong aria-hidden="true">5.</strong> DA</a></li><li class="chapter-item expanded "><a href="specs/full_node.html"><strong aria-hidden="true">6.</strong> Full Node</a></li><li class="chapter-item expanded "><a href="specs/header-sync.html"><strong aria-hidden="true">7.</strong> Header Sync</a></li><li class="chapter-item expanded "><a href="../lazy-adr/adr-014-header-and-data-separation.html"><strong aria-hidden="true">8.</strong> Header and Data Separation ADR</a></li><li class="chapter-item expanded "><a href="../lazy-adr/adr-015-rollkit-minimal-header.html"><strong aria-hidden="true">9.</strong> Rollkit Minimal Header</a></li><li class="chapter-item expanded "><a href="specs/p2p.html"><strong aria-hidden="true">10.</strong> P2P</a></li><li class="chapter-item expanded "><a href="specs/store.html"><strong aria-hidden="true">11.</strong> Store</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rollkit Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rollkit/rollkit" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the Rollkit Specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolcomponent-name"><a class="header" href="#protocolcomponent-name">Protocol/Component Name</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>Provide a concise description of the purpose of the component for which the
specification is written, along with its contribution to the rollkit or
other relevant parts of the system. Make sure to include proper references to
the relevant sections.</p>
<h2 id="protocolcomponent-description"><a class="header" href="#protocolcomponent-description">Protocol/Component Description</a></h2>
<p>Offer a comprehensive explanation of the protocol, covering aspects such as data
flow, communication mechanisms, and any other details necessary for
understanding the inner workings of this component.</p>
<h2 id="message-structurecommunication-format"><a class="header" href="#message-structurecommunication-format">Message Structure/Communication Format</a></h2>
<p>If this particular component is expected to communicate over the network,
outline the structure of the message protocol, including details such as field
interpretation, message format, and any other relevant information.</p>
<h2 id="assumptions-and-considerations"><a class="header" href="#assumptions-and-considerations">Assumptions and Considerations</a></h2>
<p>If there are any assumptions required for the component's correct operation,
performance, security, or other expected features, outline them here.
Additionally, provide any relevant considerations related to security or other
concerns.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Include a link to the location where the implementation of this protocol can be
found. Note that specific implementation details should be documented in the
rollkit repository rather than in the specification document.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>List any references used or cited in the document.</p>
<h2 id="general-tips"><a class="header" href="#general-tips">General Tips</a></h2>
<h3 id="how-to-use-a-mermaid-diagram-that-you-can-display-in-a-markdown"><a class="header" href="#how-to-use-a-mermaid-diagram-that-you-can-display-in-a-markdown">How to use a mermaid diagram that you can display in a markdown</a></h3>
<pre><code class="language-mermaid">
sequenceDiagram
    title Example
    participant A
    participant B
    A-&gt;&gt;B: Example
    B-&gt;&gt;A: Example

</code></pre>
<pre><code class="language-mermaid">
graph LR
   A[Example] --&gt; B[Example]
   B --&gt; C[Example]
   C --&gt; A

</code></pre>
<pre><code class="language-mermaid">
gantt
   title Example
   dateFormat  YYYY-MM-DD
   section Example
   A :done,    des1, 2014-01-06,2014-01-08
   B :done,    des2, 2014-01-06,2014-01-08
   C :done,    des3, 2014-01-06,2014-01-08

</code></pre>
<h3 id="grammar-and-spelling-check"><a class="header" href="#grammar-and-spelling-check">Grammar and spelling check</a></h3>
<p>The recommendation is to use your favorite spellchecker extension in your IDE like <a href="https://www.grammarly.com/">grammarly</a>, to make sure that the document is free of spelling and grammar errors.</p>
<h3 id="use-of-links"><a class="header" href="#use-of-links">Use of links</a></h3>
<p>If you want to use links use proper syntax. This goes for both internal and external links like <a href="specs/../README.html">documentation</a> or <a href="https://github.com/celestiaorg/go-header">external links</a></p>
<p>At the bottom of the document in <a href="specs/template.html#references">Reference</a>, you can add the following footnotes that will be visible in the markdown document:</p>
<p>[1] <a href="https://www.grammarly.com/">Grammarly</a></p>
<p>[2] <a href="specs/../README.html">Documentation</a></p>
<p>[3] <a href="https://github.com/celestiaorg/go-header">external links</a></p>
<p>Then at the bottom add the actual links that will not be visible in the markdown document:</p>
<h3 id="use-of-tables"><a class="header" href="#use-of-tables">Use of tables</a></h3>
<p>If you are describing variables, components or other things in a structured list that can be described in a table use the following syntax:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>type</code></td><td>Description</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rollkit-dependency-graph"><a class="header" href="#rollkit-dependency-graph">Rollkit Dependency Graph</a></h1>
<p><img src="specs/./dependency-graph.drawio.svg" alt="Dependency Graph" /></p>
<p>We use the following color coding in this Graph:</p>
<ul>
<li>No Colour: Work not yet started</li>
<li>Yellow Box: Work in progress</li>
<li>Green Box: Work completed or at least unblocking the next dependency</li>
<li>Red Border: Work needs to happen in cooperation with another team</li>
</ul>
<p>If the EPICs are not linked to the box yet, it means that this box has currently no priority or is still in the ideation phase or the dependency is unclear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-manager"><a class="header" href="#block-manager">Block Manager</a></h1>
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>The block manager is a key component of full nodes and is responsible for block production or block syncing depending on the node type: sequencer or non-sequencer. Block syncing in this context includes retrieving the published blocks from the network (P2P network or DA network), validating them to raise fraud proofs upon validation failure, updating the state, and storing the validated blocks. A full node invokes multiple block manager functionalities in parallel, such as:</p>
<ul>
<li>Block Production (only for sequencer full nodes)</li>
<li>Block Publication to DA network</li>
<li>Block Retrieval from DA network</li>
<li>Block Sync Service</li>
<li>Block Publication to P2P network</li>
<li>Block Retrieval from P2P network</li>
<li>State Update after Block Retrieval</li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
    title Overview of Block Manager

    participant User
    participant Sequencer
    participant Full Node 1
    participant Full Node 2
    participant DA Layer

    User-&gt;&gt;Sequencer: Send Tx
    Sequencer-&gt;&gt;Sequencer: Generate Block
    Sequencer-&gt;&gt;DA Layer: Publish Block

    Sequencer-&gt;&gt;Full Node 1: Gossip Block
    Sequencer-&gt;&gt;Full Node 2: Gossip Block
    Full Node 1-&gt;&gt;Full Node 1: Verify Block
    Full Node 1-&gt;&gt;Full Node 2: Gossip Block
    Full Node 1-&gt;&gt;Full Node 1: Mark Block Soft Confirmed

    Full Node 2-&gt;&gt;Full Node 2: Verify Block
    Full Node 2-&gt;&gt;Full Node 2: Mark Block Soft Confirmed

    DA Layer-&gt;&gt;Full Node 1: Retrieve Block
    Full Node 1-&gt;&gt;Full Node 1: Mark Block DA Included

    DA Layer-&gt;&gt;Full Node 2: Retrieve Block
    Full Node 2-&gt;&gt;Full Node 2: Mark Block DA Included
</code></pre>
<h3 id="component-architecture-overview"><a class="header" href="#component-architecture-overview">Component Architecture Overview</a></h3>
<pre><code class="language-mermaid">flowchart TB
    subgraph Block Manager Components
        BM[Block Manager]
        AGG[Aggregation]
        REP[Reaper]
        SUB[Submitter]
        RET[Retriever]
        SYNC[Sync Loop]
        DAI[DA Includer]
    end
    
    subgraph External Components
        EX[Executor]
        SEQ[Sequencer]
        DA[DA Layer]
        HS[Header Store/P2P]
        DS[Data Store/P2P]
        ST[Local Store]
    end
    
    REP --&gt;|GetTxs| EX
    REP --&gt;|SubmitBatch| SEQ
    REP --&gt;|Notify| AGG
    
    AGG --&gt;|CreateBlock| BM
    BM --&gt;|ApplyBlock| EX
    BM --&gt;|Save| ST
    
    BM --&gt;|Headers| SUB
    BM --&gt;|Data| SUB
    SUB --&gt;|Submit| DA
    
    RET --&gt;|Retrieve| DA
    RET --&gt;|Headers/Data| SYNC
    
    HS --&gt;|Headers| SYNC
    DS --&gt;|Data| SYNC
    
    SYNC --&gt;|Complete Blocks| BM
    SYNC --&gt;|DA Included| DAI
    DAI --&gt;|SetFinal| EX
</code></pre>
<h2 id="protocolcomponent-description-1"><a class="header" href="#protocolcomponent-description-1">Protocol/Component Description</a></h2>
<p>The block manager is initialized using several parameters as defined below:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Name</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>signing key</td><td>crypto.PrivKey</td><td>used for signing blocks and data after creation</td></tr>
<tr><td>config</td><td>config.BlockManagerConfig</td><td>block manager configurations (see config options below)</td></tr>
<tr><td>genesis</td><td>*cmtypes.GenesisDoc</td><td>initialize the block manager with genesis state (genesis configuration defined in <code>config/genesis.json</code> file under the app directory)</td></tr>
<tr><td>store</td><td>store.Store</td><td>local datastore for storing rollup blocks and states (default local store path is <code>$db_dir/rollkit</code> and <code>db_dir</code> specified in the <code>config.yaml</code> file under the app directory)</td></tr>
<tr><td>mempool, proxyapp, eventbus</td><td>mempool.Mempool, proxy.AppConnConsensus, *cmtypes.EventBus</td><td>for initializing the executor (state transition function). mempool is also used in the manager to check for availability of transactions for lazy block production</td></tr>
<tr><td>dalc</td><td>da.DAClient</td><td>the data availability light client used to submit and retrieve blocks to DA network</td></tr>
<tr><td>headerStore</td><td>*goheaderstore.Store[*types.SignedHeader]</td><td>to store and retrieve block headers gossiped over the P2P network</td></tr>
<tr><td>dataStore</td><td>*goheaderstore.Store[*types.SignedData]</td><td>to store and retrieve block data gossiped over the P2P network</td></tr>
<tr><td>signaturePayloadProvider</td><td>types.SignaturePayloadProvider</td><td>optional custom provider for header signature payloads</td></tr>
<tr><td>sequencer</td><td>core.Sequencer</td><td>used to retrieve batches of transactions from the sequencing layer</td></tr>
<tr><td>reaper</td><td>*Reaper</td><td>component that periodically retrieves transactions from the executor and submits them to the sequencer</td></tr>
</tbody></table>
</div>
<p>Block manager configuration options:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>BlockTime</td><td>time.Duration</td><td>time interval used for block production and block retrieval from block store (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L36"><code>defaultBlockTime</code></a>)</td></tr>
<tr><td>DABlockTime</td><td>time.Duration</td><td>time interval used for both block publication to DA network and block retrieval from DA network (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L33"><code>defaultDABlockTime</code></a>)</td></tr>
<tr><td>DAStartHeight</td><td>uint64</td><td>block retrieval from DA network starts from this height</td></tr>
<tr><td>LazyBlockInterval</td><td>time.Duration</td><td>time interval used for block production in lazy aggregator mode even when there are no transactions (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L39"><code>defaultLazyBlockTime</code></a>)</td></tr>
<tr><td>LazyMode</td><td>bool</td><td>when set to true, enables lazy aggregation mode which produces blocks only when transactions are available or at LazyBlockInterval intervals</td></tr>
<tr><td>MaxPendingHeadersAndData</td><td>uint64</td><td>maximum number of pending headers and data blocks before pausing block production (default: 100)</td></tr>
<tr><td>GasPrice</td><td>float64</td><td>gas price for DA submissions (-1 for automatic/default)</td></tr>
<tr><td>GasMultiplier</td><td>float64</td><td>multiplier for gas price on DA submission retries (default: 1.3)</td></tr>
<tr><td>Namespace</td><td>da.Namespace</td><td>DA namespace ID for block submissions</td></tr>
</tbody></table>
</div>
<h3 id="block-production"><a class="header" href="#block-production">Block Production</a></h3>
<p>When the full node is operating as a sequencer (aka aggregator), the block manager runs the block production logic. There are two modes of block production, which can be specified in the block manager configurations: <code>normal</code> and <code>lazy</code>.</p>
<p>In <code>normal</code> mode, the block manager runs a timer, which is set to the <code>BlockTime</code> configuration parameter, and continuously produces blocks at <code>BlockTime</code> intervals.</p>
<p>In <code>lazy</code> mode, the block manager implements a dual timer mechanism:</p>
<pre><code class="language-mermaid">flowchart LR
    subgraph Lazy Aggregation Mode
        R[Reaper] --&gt;|GetTxs| E[Executor]
        E --&gt;|Txs Available| R
        R --&gt;|Submit to Sequencer| S[Sequencer]
        R --&gt;|NotifyNewTransactions| N[txNotifyCh]
        
        N --&gt; A{Aggregation Logic}
        BT[blockTimer] --&gt; A
        LT[lazyTimer] --&gt; A
        
        A --&gt;|Txs Available| P1[Produce Block with Txs]
        A --&gt;|No Txs &amp; LazyTimer| P2[Produce Empty Block]
        
        P1 --&gt; B[Block Creation]
        P2 --&gt; B
    end
</code></pre>
<ol>
<li>A <code>blockTimer</code> that triggers block production at regular intervals when transactions are available</li>
<li>A <code>lazyTimer</code> that ensures blocks are produced at <code>LazyBlockInterval</code> intervals even during periods of inactivity</li>
</ol>
<p>The block manager starts building a block when any transaction becomes available in the mempool via a notification channel (<code>txNotifyCh</code>). When the <code>Reaper</code> detects new transactions, it calls <code>Manager.NotifyNewTransactions()</code>, which performs a non-blocking signal on this channel. The block manager also produces empty blocks at regular intervals to maintain consistency with the DA layer, ensuring a 1:1 mapping between DA layer blocks and execution layer blocks.</p>
<p>The Reaper component periodically retrieves transactions from the executor and submits them to the sequencer. It runs independently and notifies the block manager when new transactions are available, enabling responsive block production in lazy mode.</p>
<h4 id="building-the-block"><a class="header" href="#building-the-block">Building the Block</a></h4>
<p>The block manager of the sequencer nodes performs the following steps to produce a block:</p>
<pre><code class="language-mermaid">flowchart TD
    A[Timer Trigger / Transaction Notification] --&gt; B[Retrieve Batch]
    B --&gt; C{Transactions Available?}
    C --&gt;|Yes| D[Create Block with Txs]
    C --&gt;|No| E[Create Empty Block]
    D --&gt; F[Generate Header &amp; Data]
    E --&gt; F
    F --&gt; G[Sign Header → SignedHeader]
    F --&gt; H[Sign Data → SignedData]
    G --&gt; I[Apply Block]
    H --&gt; I
    I --&gt; J[Update State]
    J --&gt; K[Save to Store]
    K --&gt; L[Add to pendingHeaders]
    K --&gt; M[Add to pendingData]
    L --&gt; N[Broadcast Header to P2P]
    M --&gt; O[Broadcast Data to P2P]
</code></pre>
<ul>
<li>Retrieve a batch of transactions using <code>retrieveBatch()</code> which interfaces with the sequencer</li>
<li>Call <code>CreateBlock</code> using executor with the retrieved transactions</li>
<li>Create separate header and data structures from the block</li>
<li>Sign the header using <code>signing key</code> to generate <code>SignedHeader</code></li>
<li>Sign the data using <code>signing key</code> to generate <code>SignedData</code> (if transactions exist)</li>
<li>Call <code>ApplyBlock</code> using executor to generate an updated state</li>
<li>Save the block, validators, and updated state to local store</li>
<li>Add the newly generated header to <code>pendingHeaders</code> queue</li>
<li>Add the newly generated data to <code>pendingData</code> queue (if not empty)</li>
<li>Publish the newly generated header and data to channels to notify other components of the sequencer node (such as block and header gossip)</li>
</ul>
<p>Note: When no transactions are available, the block manager creates blocks with empty data using a special <code>dataHashForEmptyTxs</code> marker. The header and data separation architecture allows headers and data to be submitted and retrieved independently from the DA layer.</p>
<h3 id="block-publication-to-da-network"><a class="header" href="#block-publication-to-da-network">Block Publication to DA Network</a></h3>
<p>The block manager of the sequencer full nodes implements separate submission loops for headers and data, both operating at <code>DABlockTime</code> intervals:</p>
<pre><code class="language-mermaid">flowchart LR
    subgraph Header Submission
        H1[pendingHeaders Queue] --&gt; H2[Header Submission Loop]
        H2 --&gt; H3[Marshal to Protobuf]
        H3 --&gt; H4[Submit to DA]
        H4 --&gt;|Success| H5[Remove from Queue]
        H4 --&gt;|Failure| H6[Keep in Queue &amp; Retry]
    end
    
    subgraph Data Submission
        D1[pendingData Queue] --&gt; D2[Data Submission Loop]
        D2 --&gt; D3[Marshal to Protobuf]
        D3 --&gt; D4[Submit to DA]
        D4 --&gt;|Success| D5[Remove from Queue]
        D4 --&gt;|Failure| D6[Keep in Queue &amp; Retry]
    end
    
    H2 -.-&gt;|DABlockTime| H2
    D2 -.-&gt;|DABlockTime| D2
</code></pre>
<h4 id="header-submission-loop"><a class="header" href="#header-submission-loop">Header Submission Loop</a></h4>
<p>The <code>HeaderSubmissionLoop</code> manages the submission of signed headers to the DA network:</p>
<ul>
<li>Retrieves pending headers from the <code>pendingHeaders</code> queue</li>
<li>Marshals headers to protobuf format</li>
<li>Submits to DA using the generic <code>submitToDA</code> helper</li>
<li>On success, removes submitted headers from the pending queue</li>
<li>On failure, headers remain in the queue for retry</li>
</ul>
<h4 id="data-submission-loop"><a class="header" href="#data-submission-loop">Data Submission Loop</a></h4>
<p>The <code>DataSubmissionLoop</code> manages the submission of signed data to the DA network:</p>
<ul>
<li>Retrieves pending data from the <code>pendingData</code> queue</li>
<li>Marshals data to protobuf format</li>
<li>Submits to DA using the generic <code>submitToDA</code> helper</li>
<li>On success, removes submitted data from the pending queue</li>
<li>On failure, data remains in the queue for retry</li>
</ul>
<h4 id="generic-submission-logic"><a class="header" href="#generic-submission-logic">Generic Submission Logic</a></h4>
<p>Both loops use a shared <code>submitToDA</code> function that provides:</p>
<ul>
<li>Retry logic with <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L50"><code>maxSubmitAttempts</code></a> attempts</li>
<li>Exponential backoff starting at <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L59"><code>initialBackoff</code></a>, doubling each attempt, capped at <code>DABlockTime</code></li>
<li>Gas price management with <code>GasMultiplier</code> applied on retries</li>
<li>Comprehensive metrics tracking for attempts, successes, and failures</li>
<li>Context-aware cancellation support</li>
</ul>
<p>The manager enforces a limit on pending headers and data through <code>MaxPendingHeadersAndData</code> configuration. When this limit is reached, block production pauses to prevent unbounded growth of the pending queues.</p>
<h3 id="block-retrieval-from-da-network"><a class="header" href="#block-retrieval-from-da-network">Block Retrieval from DA Network</a></h3>
<p>The block manager implements a <code>RetrieveLoop</code> that regularly pulls headers and data from the DA network:</p>
<pre><code class="language-mermaid">flowchart TD
    A[Start RetrieveLoop] --&gt; B[Get DA Height]
    B --&gt; C{DABlockTime Timer}
    C --&gt; D[GetHeightPair from DA]
    D --&gt; E{Result?}
    E --&gt;|Success| F[Validate Signatures]
    E --&gt;|NotFound| G[Increment Height]
    E --&gt;|Error| H[Retry Logic]
    
    F --&gt; I[Check Sequencer Info]
    I --&gt; J[Mark DA Included]
    J --&gt; K[Send to Sync]
    K --&gt; L[Increment Height]
    L --&gt; M[Immediate Next Retrieval]
    
    G --&gt; C
    H --&gt; N{Retries &lt; 10?}
    N --&gt;|Yes| O[Wait 100ms]
    N --&gt;|No| P[Log Error &amp; Stall]
    O --&gt; D
    M --&gt; D
</code></pre>
<h4 id="retrieval-process"><a class="header" href="#retrieval-process">Retrieval Process</a></h4>
<ol>
<li>
<p><strong>Height Management</strong>: Starts from the latest of:</p>
<ul>
<li>DA height from the last state in local store</li>
<li><code>DAStartHeight</code> configuration parameter</li>
<li>Maintains and increments <code>daHeight</code> counter after successful retrievals</li>
</ul>
</li>
<li>
<p><strong>Retrieval Mechanism</strong>:</p>
<ul>
<li>Executes at <code>DABlockTime</code> intervals</li>
<li>Makes <code>GetHeightPair(daHeight)</code> request to get both header and data</li>
<li>Handles three possible outcomes:
<ul>
<li><code>Success</code>: Process retrieved header and data</li>
<li><code>NotFound</code>: No rollup block at this DA height (normal case)</li>
<li><code>Error</code>: Retry with backoff</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Implements retry logic with 100ms delay between attempts</li>
<li>After 10 retries, logs error and stalls retrieval</li>
<li>Does not increment <code>daHeight</code> on persistent errors</li>
</ul>
</li>
<li>
<p><strong>Processing Retrieved Blocks</strong>:</p>
<ul>
<li>Validates header and data signatures</li>
<li>Checks sequencer information</li>
<li>Marks blocks as DA included in caches</li>
<li>Sends to sync goroutine for state update</li>
<li>Successful processing triggers immediate next retrieval without waiting for timer</li>
</ul>
</li>
</ol>
<h4 id="header-and-data-caching"><a class="header" href="#header-and-data-caching">Header and Data Caching</a></h4>
<p>The retrieval system uses persistent caches for both headers and data:</p>
<ul>
<li>Prevents duplicate processing</li>
<li>Tracks DA inclusion status</li>
<li>Supports out-of-order block arrival</li>
<li>Enables efficient sync from P2P and DA sources</li>
</ul>
<p>For more details on DA integration, see the <a href="specs/./da.html">Data Availability specification</a>.</p>
<h4 id="out-of-order-rollup-blocks-on-da"><a class="header" href="#out-of-order-rollup-blocks-on-da">Out-of-Order Rollup Blocks on DA</a></h4>
<p>Rollkit should support blocks arriving out-of-order on DA, like so:
<img src="specs/./out-of-order-blocks.png" alt="out-of-order blocks" /></p>
<h4 id="termination-condition"><a class="header" href="#termination-condition">Termination Condition</a></h4>
<p>If the sequencer double-signs two blocks at the same height, evidence of the fault should be posted to DA. Rollkit full nodes should process the longest valid chain up to the height of the fault evidence, and terminate. See diagram:
<img src="specs/./termination.png" alt="termination conidition" /></p>
<h3 id="block-sync-service"><a class="header" href="#block-sync-service">Block Sync Service</a></h3>
<p>The block sync service manages the synchronization of headers and data through separate stores and channels:</p>
<h4 id="architecture"><a class="header" href="#architecture">Architecture</a></h4>
<ul>
<li><strong>Header Store</strong>: Uses <code>goheader.Store[*types.SignedHeader]</code> for header management</li>
<li><strong>Data Store</strong>: Uses <code>goheader.Store[*types.SignedData]</code> for data management</li>
<li><strong>Separation of Concerns</strong>: Headers and data are handled independently, supporting the header/data separation architecture</li>
</ul>
<h4 id="synchronization-flow"><a class="header" href="#synchronization-flow">Synchronization Flow</a></h4>
<ol>
<li><strong>Header Sync</strong>: Headers created by the sequencer are sent to the header store for P2P gossip</li>
<li><strong>Data Sync</strong>: Data blocks are sent to the data store for P2P gossip</li>
<li><strong>Cache Integration</strong>: Both header and data caches track seen items to prevent duplicates</li>
<li><strong>DA Inclusion Tracking</strong>: Separate tracking for header and data DA inclusion status</li>
</ol>
<h3 id="block-publication-to-p2p-network"><a class="header" href="#block-publication-to-p2p-network">Block Publication to P2P network</a></h3>
<p>The sequencer publishes headers and data separately to the P2P network:</p>
<h4 id="header-publication"><a class="header" href="#header-publication">Header Publication</a></h4>
<ul>
<li>Headers are sent through the header broadcast channel</li>
<li>Written to the header store for P2P gossip</li>
<li>Broadcast to network peers via header sync service</li>
</ul>
<h4 id="data-publication"><a class="header" href="#data-publication">Data Publication</a></h4>
<ul>
<li>Data blocks are sent through the data broadcast channel</li>
<li>Written to the data store for P2P gossip</li>
<li>Broadcast to network peers via data sync service</li>
</ul>
<p>Non-sequencer full nodes receive headers and data through the P2P sync service and do not publish blocks themselves.</p>
<h3 id="block-retrieval-from-p2p-network"><a class="header" href="#block-retrieval-from-p2p-network">Block Retrieval from P2P network</a></h3>
<p>Non-sequencer full nodes retrieve headers and data separately from P2P stores:</p>
<h4 id="header-store-retrieval-loop"><a class="header" href="#header-store-retrieval-loop">Header Store Retrieval Loop</a></h4>
<p>The <code>HeaderStoreRetrieveLoop</code>:</p>
<ul>
<li>Operates at <code>BlockTime</code> intervals via <code>headerStoreCh</code> signals</li>
<li>Tracks <code>headerStoreHeight</code> for the last retrieved header</li>
<li>Retrieves all headers between last height and current store height</li>
<li>Validates sequencer information using <code>isUsingExpectedSingleSequencer</code></li>
<li>Marks headers as &quot;seen&quot; in the header cache</li>
<li>Sends headers to sync goroutine via <code>headerInCh</code></li>
</ul>
<h4 id="data-store-retrieval-loop"><a class="header" href="#data-store-retrieval-loop">Data Store Retrieval Loop</a></h4>
<p>The <code>DataStoreRetrieveLoop</code>:</p>
<ul>
<li>Operates at <code>BlockTime</code> intervals via <code>dataStoreCh</code> signals</li>
<li>Tracks <code>dataStoreHeight</code> for the last retrieved data</li>
<li>Retrieves all data blocks between last height and current store height</li>
<li>Validates data signatures using <code>isValidSignedData</code></li>
<li>Marks data as &quot;seen&quot; in the data cache</li>
<li>Sends data to sync goroutine via <code>dataInCh</code></li>
</ul>
<h4 id="soft-confirmations"><a class="header" href="#soft-confirmations">Soft Confirmations</a></h4>
<p>Headers and data retrieved from P2P are marked as soft confirmed until both:</p>
<ol>
<li>The corresponding header is seen on the DA layer</li>
<li>The corresponding data is seen on the DA layer</li>
</ol>
<p>Once both conditions are met, the block is marked as DA-included.</p>
<h4 id="about-soft-confirmations-and-da-inclusions"><a class="header" href="#about-soft-confirmations-and-da-inclusions">About Soft Confirmations and DA Inclusions</a></h4>
<p>The block manager retrieves blocks from both the P2P network and the underlying DA network because the blocks are available in the P2P network faster and DA retrieval is slower (e.g., 1 second vs 6 seconds).<br />
The blocks retrieved from the P2P network are only marked as soft confirmed until the DA retrieval succeeds on those blocks and they are marked DA-included.<br />
DA-included blocks are considered to have a higher level of finality.</p>
<p><strong>DAIncluderLoop</strong>:<br />
The <code>DAIncluderLoop</code> is responsible for advancing the <code>DAIncludedHeight</code> by:</p>
<ul>
<li>Checking if blocks after the current height have both header and data marked as DA-included in caches</li>
<li>Stopping advancement if either header or data is missing for a height</li>
<li>Calling <code>SetFinal</code> on the executor when a block becomes DA-included</li>
<li>Storing the Rollkit height to DA height mapping for tracking</li>
<li>Ensuring only blocks with both header and data present are considered DA-included</li>
</ul>
<h3 id="state-update-after-block-retrieval"><a class="header" href="#state-update-after-block-retrieval">State Update after Block Retrieval</a></h3>
<p>The block manager uses a <code>SyncLoop</code> to coordinate state updates from blocks retrieved via P2P or DA networks:</p>
<pre><code class="language-mermaid">flowchart TD
    subgraph Sources
        P1[P2P Header Store] --&gt; H[headerInCh]
        P2[P2P Data Store] --&gt; D[dataInCh]
        DA1[DA Header Retrieval] --&gt; H
        DA2[DA Data Retrieval] --&gt; D
    end
    
    subgraph SyncLoop
        H --&gt; S[Sync Goroutine]
        D --&gt; S
        S --&gt; C{Header &amp; Data for Same Height?}
        C --&gt;|Yes| R[Reconstruct Block]
        C --&gt;|No| W[Wait for Matching Pair]
        R --&gt; V[Validate Signatures]
        V --&gt; A[ApplyBlock]
        A --&gt; CM[Commit]
        CM --&gt; ST[Store Block &amp; State]
        ST --&gt; F{DA Included?}
        F --&gt;|Yes| FN[SetFinal]
        F --&gt;|No| E[End]
        FN --&gt; U[Update DA Height]
    end
</code></pre>
<h4 id="sync-loop-architecture"><a class="header" href="#sync-loop-architecture">Sync Loop Architecture</a></h4>
<p>The <code>SyncLoop</code> processes headers and data from multiple sources:</p>
<ul>
<li>Headers from <code>headerInCh</code> (P2P and DA sources)</li>
<li>Data from <code>dataInCh</code> (P2P and DA sources)</li>
<li>Maintains caches to track processed items</li>
<li>Ensures ordered processing by height</li>
</ul>
<h4 id="state-update-process"><a class="header" href="#state-update-process">State Update Process</a></h4>
<p>When both header and data are available for a height:</p>
<ol>
<li><strong>Block Reconstruction</strong>: Combines header and data into a complete block</li>
<li><strong>Validation</strong>: Verifies header and data signatures match expectations</li>
<li><strong>ApplyBlock</strong>:
<ul>
<li>Validates the block against current state</li>
<li>Executes transactions</li>
<li>Captures validator updates</li>
<li>Returns updated state</li>
</ul>
</li>
<li><strong>Commit</strong>:
<ul>
<li>Persists execution results</li>
<li>Updates mempool by removing included transactions</li>
<li>Publishes block events</li>
</ul>
</li>
<li><strong>Storage</strong>:
<ul>
<li>Stores the block, validators, and updated state</li>
<li>Updates last state in manager</li>
</ul>
</li>
<li><strong>Finalization</strong>:
<ul>
<li>When block is DA-included, calls <code>SetFinal</code> on executor</li>
<li>Updates DA included height</li>
</ul>
</li>
</ol>
<h2 id="message-structurecommunication-format-1"><a class="header" href="#message-structurecommunication-format-1">Message Structure/Communication Format</a></h2>
<p>The communication between the block manager and executor:</p>
<ul>
<li><code>InitChain</code>: initializes the chain state with the given genesis time, initial height, and chain ID using <code>InitChainSync</code> on the executor to obtain initial <code>appHash</code> and initialize the state.</li>
<li><code>CreateBlock</code>: prepares a block with transactions from the provided batch data.</li>
<li><code>ApplyBlock</code>: validates the block, executes the block (apply transactions), captures validator updates, and returns updated state.</li>
<li><code>SetFinal</code>: marks the block as final when both its header and data are confirmed on the DA layer.</li>
<li><code>GetTxs</code>: retrieves transactions from the application (used by Reaper component).</li>
</ul>
<p>The communication with the sequencer:</p>
<ul>
<li><code>GetNextBatch</code>: retrieves the next batch of transactions to include in a block.</li>
<li><code>VerifyBatch</code>: validates that a batch came from the expected sequencer.</li>
</ul>
<p>The communication with DA layer:</p>
<ul>
<li><code>Submit</code>: submits headers or data blobs to the DA network.</li>
<li><code>Get</code>: retrieves headers or data blobs from the DA network.</li>
<li><code>GetHeightPair</code>: retrieves both header and data at a specific DA height.</li>
</ul>
<h2 id="assumptions-and-considerations-1"><a class="header" href="#assumptions-and-considerations-1">Assumptions and Considerations</a></h2>
<ul>
<li>The block manager loads the initial state from the local store and uses genesis if not found in the local store, when the node (re)starts.</li>
<li>The default mode for sequencer nodes is normal (not lazy).</li>
<li>The sequencer can produce empty blocks.</li>
<li>In lazy aggregation mode, the block manager maintains consistency with the DA layer by producing empty blocks at regular intervals, ensuring a 1:1 mapping between DA layer blocks and execution layer blocks.</li>
<li>The lazy aggregation mechanism uses a dual timer approach:
<ul>
<li>A <code>blockTimer</code> that triggers block production when transactions are available</li>
<li>A <code>lazyTimer</code> that ensures blocks are produced even during periods of inactivity</li>
</ul>
</li>
<li>Empty batches are handled differently in lazy mode - instead of discarding them, they are returned with the <code>ErrNoBatch</code> error, allowing the caller to create empty blocks with proper timestamps.</li>
<li>Transaction notifications from the <code>Reaper</code> to the <code>Manager</code> are handled via a non-blocking notification channel (<code>txNotifyCh</code>) to prevent backpressure.</li>
<li>The block manager enforces <code>MaxPendingHeadersAndData</code> limit to prevent unbounded growth of pending queues during DA submission issues.</li>
<li>Headers and data are submitted separately to the DA layer, supporting the header/data separation architecture.</li>
<li>The block manager uses persistent caches for headers and data to track seen items and DA inclusion status.</li>
<li>Gas price management includes automatic adjustment with <code>GasMultiplier</code> on DA submission retries.</li>
<li>The block manager uses persistent storage (disk) when the <code>root_dir</code> and <code>db_path</code> configuration parameters are specified in <code>config.yaml</code> file under the app directory. If these configuration parameters are not specified, the in-memory storage is used, which will not be persistent if the node stops.</li>
<li>The block manager does not re-apply blocks when they transition from soft confirmed to DA included status. The block is only marked DA included in the caches.</li>
<li>Header and data stores use separate prefixes for isolation in the underlying database.</li>
<li>The genesis <code>ChainID</code> is used to create separate <code>PubSubTopID</code>s for headers and data in go-header.</li>
<li>Block sync over the P2P network works only when a full node is connected to the P2P network by specifying the initial seeds to connect to via <code>P2PConfig.Seeds</code> configuration parameter when starting the full node.</li>
<li>Node's context is passed down to all components to support graceful shutdown and cancellation.</li>
<li>The block manager supports custom signature payload providers for headers, enabling flexible signing schemes.</li>
<li>The block manager supports the separation of header and data structures in Rollkit. This allows for expanding the sequencing scheme beyond single sequencing and enables the use of a decentralized sequencer mode. For detailed information on this architecture, see the <a href="specs/../../lazy-adr/adr-014-header-and-data-separation.html">Header and Data Separation ADR</a>.</li>
<li>The block manager processes blocks with a minimal header format, which is designed to eliminate dependency on CometBFT's header format and can be used to produce an execution layer tailored header if needed. For details on this header structure, see the <a href="specs/../../lazy-adr/adr-015-rollkit-minimal-header.html">Rollkit Minimal Header</a> specification.</li>
</ul>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<p>The block manager exposes comprehensive metrics for monitoring:</p>
<h3 id="block-production-metrics"><a class="header" href="#block-production-metrics">Block Production Metrics</a></h3>
<ul>
<li><code>last_block_produced_height</code>: Height of the last produced block</li>
<li><code>last_block_produced_time</code>: Timestamp of the last produced block</li>
<li><code>aggregation_type</code>: Current aggregation mode (normal/lazy)</li>
<li><code>block_size_bytes</code>: Size distribution of produced blocks</li>
<li><code>produced_empty_blocks_total</code>: Count of empty blocks produced</li>
</ul>
<h3 id="da-metrics"><a class="header" href="#da-metrics">DA Metrics</a></h3>
<ul>
<li><code>da_submission_attempts_total</code>: Total DA submission attempts</li>
<li><code>da_submission_success_total</code>: Successful DA submissions</li>
<li><code>da_submission_failure_total</code>: Failed DA submissions</li>
<li><code>da_retrieval_attempts_total</code>: Total DA retrieval attempts</li>
<li><code>da_retrieval_success_total</code>: Successful DA retrievals</li>
<li><code>da_retrieval_failure_total</code>: Failed DA retrievals</li>
<li><code>da_height</code>: Current DA retrieval height</li>
<li><code>pending_headers_count</code>: Number of headers pending DA submission</li>
<li><code>pending_data_count</code>: Number of data blocks pending DA submission</li>
</ul>
<h3 id="sync-metrics"><a class="header" href="#sync-metrics">Sync Metrics</a></h3>
<ul>
<li><code>sync_height</code>: Current sync height</li>
<li><code>da_included_height</code>: Height of last DA-included block</li>
<li><code>soft_confirmed_height</code>: Height of last soft confirmed block</li>
<li><code>header_store_height</code>: Current header store height</li>
<li><code>data_store_height</code>: Current data store height</li>
</ul>
<h3 id="performance-metrics"><a class="header" href="#performance-metrics">Performance Metrics</a></h3>
<ul>
<li><code>block_production_time</code>: Time to produce a block</li>
<li><code>da_submission_time</code>: Time to submit to DA</li>
<li><code>state_update_time</code>: Time to apply block and update state</li>
<li><code>channel_buffer_usage</code>: Usage of internal channels</li>
</ul>
<h3 id="error-metrics"><a class="header" href="#error-metrics">Error Metrics</a></h3>
<ul>
<li><code>errors_total</code>: Total errors by type and operation</li>
</ul>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">block-manager</a></p>
<p>See <a href="https://rollkit.dev/guides/full-node">tutorial</a> for running a multi-node network with both sequencer and non-sequencer full nodes.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>[1] <a href="https://github.com/celestiaorg/go-header">Go Header</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Block Sync</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[5] <a href="https://rollkit.dev/guides/full-node">Tutorial</a></p>
<p>[6] <a href="specs/../../lazy-adr/adr-014-header-and-data-separation.html">Header and Data Separation ADR</a></p>
<p>[7] <a href="specs/../../lazy-adr/adr-015-rollkit-minimal-header.html">Rollkit Minimal Header</a></p>
<p>[8] <a href="specs/./da.html">Data Availability</a></p>
<p>[9] <a href="specs/../../lazy-adr/adr-021-lazy-aggregation.html">Lazy Aggregation with DA Layer Consistency ADR</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-and-header-validity"><a class="header" href="#block-and-header-validity">Block and Header Validity</a></h1>
<h2 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h2>
<p>Like all blockchains, rollups are defined as the chain of <strong>valid</strong> blocks from the genesis, to the head. Thus, the block and header validity rules define the chain.</p>
<p>Verifying a block/header is done in 3 parts:</p>
<ol>
<li>
<p>Verify correct serialization according to the protobuf spec</p>
</li>
<li>
<p>Perform basic validation of the types</p>
</li>
<li>
<p>Perform verification of the new block against the previously accepted block</p>
</li>
</ol>
<p>Rollkit uses a header/data separation architecture where headers and data can be validated independently. The system has moved from a multi-validator model to a single signer model for simplified sequencer management.</p>
<h2 id="basic-validation"><a class="header" href="#basic-validation">Basic Validation</a></h2>
<p>Each type contains a <code>.ValidateBasic()</code> method, which verifies that certain basic invariants hold. The <code>ValidateBasic()</code> calls are nested for each structure.</p>
<h3 id="signedheader-validation"><a class="header" href="#signedheader-validation">SignedHeader Validation</a></h3>
<pre><code class="language-go">SignedHeader.ValidateBasic()
  // Make sure the SignedHeader's Header passes basic validation
  Header.ValidateBasic()
    verify ProposerAddress not nil
  // Make sure the SignedHeader's signature passes basic validation
  Signature.ValidateBasic()
    // Ensure that someone signed the header
    verify len(c.Signatures) not 0
  // For based rollups (sh.Signer.IsEmpty()), pass validation
  If !sh.Signer.IsEmpty():
    // Verify the signer matches the proposer address
    verify sh.Signer.Address == sh.ProposerAddress
    // Verify signature using custom verifier if set, otherwise use default
    if sh.verifier != nil:
      verify sh.verifier(sh) == nil
    else:
      verify sh.Signature.Verify(sh.Signer.PubKey, sh.Header.MarshalBinary())
</code></pre>
<h3 id="signeddata-validation"><a class="header" href="#signeddata-validation">SignedData Validation</a></h3>
<pre><code class="language-go">SignedData.ValidateBasic()
  // Always passes basic validation for the Data itself
  Data.ValidateBasic() // always passes
  // Make sure the signature is valid
  Signature.ValidateBasic()
    verify len(c.Signatures) not 0
  // Verify the signer
  If !sd.Signer.IsEmpty():
    verify sd.Signature.Verify(sd.Signer.PubKey, sd.Data.MarshalBinary())
</code></pre>
<h3 id="block-validation"><a class="header" href="#block-validation">Block Validation</a></h3>
<p>Blocks are composed of SignedHeader and Data:</p>
<pre><code class="language-go">// Block validation happens by validating header and data separately
// then ensuring data hash matches
verify SignedHeader.ValidateBasic() == nil
verify Data.Hash() == SignedHeader.DataHash
</code></pre>
<h2 id="verification-against-previous-block"><a class="header" href="#verification-against-previous-block">Verification Against Previous Block</a></h2>
<pre><code class="language-go">SignedHeader.Verify(untrustedHeader *SignedHeader)
  // Basic validation is handled by go-header before this
  Header.Verify(untrustedHeader)
    // Verify height sequence
    if untrustedHeader.Height != h.Height + 1:
      if untrustedHeader.Height &gt; h.Height + 1:
        return soft verification failure
      return error &quot;headers are not adjacent&quot;
    // Verify the link to previous header
    verify untrustedHeader.LastHeaderHash == h.Header.Hash()
    // Verify LastCommit hash matches previous signature
    verify untrustedHeader.LastCommitHash == sh.Signature.GetCommitHash(...)
    // Note: ValidatorHash field exists for compatibility but is not validated
</code></pre>
<h2 id="data"><a class="header" href="#data"><a href="https://github.com/rollkit/rollkit/blob/main/types/data.go">Data</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>Txs</td><td>Transaction data of the block</td><td>Data.Hash() == SignedHeader.DataHash</td></tr>
<tr><td>Metadata</td><td>Optional p2p gossiping metadata</td><td>Not validated</td></tr>
</tbody></table>
</div>
<h2 id="signedheader"><a class="header" href="#signedheader"><a href="https://github.com/rollkit/rollkit/blob/main/types/signed_header.go">SignedHeader</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>Header</td><td>Valid header for the block</td><td><code>Header</code> passes <code>ValidateBasic()</code> and <code>Verify()</code></td></tr>
<tr><td>Signature</td><td>Valid signature from the single sequencer</td><td><code>Signature</code> passes <code>ValidateBasic()</code>, verified against signer</td></tr>
<tr><td>Signer</td><td>Information about who signed the header</td><td>Must match ProposerAddress if not empty (based rollup case)</td></tr>
<tr><td>verifier</td><td>Optional custom signature verification function</td><td>Used instead of default verification if set</td></tr>
</tbody></table>
</div>
<h2 id="header"><a class="header" href="#header"><a href="https://github.com/rollkit/rollkit/blob/main/types/header.go">Header</a></a></h2>
<p><em><strong>Note</strong></em>: Rollkit has moved to a single signer model. The multi-validator architecture has been replaced with a simpler single sequencer approach.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td><strong>BaseHeader</strong> .</td><td></td><td></td></tr>
<tr><td>Height</td><td>Height of the previous accepted header, plus 1.</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>Time</td><td>Timestamp of the block</td><td>Not validated in Rollkit</td></tr>
<tr><td>ChainID</td><td>The hard-coded ChainID of the chain</td><td>Should be checked as soon as the header is received</td></tr>
<tr><td><strong>Header</strong> .</td><td></td><td></td></tr>
<tr><td>Version</td><td>unused</td><td></td></tr>
<tr><td>LastHeaderHash</td><td>The hash of the previous accepted block</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>LastCommitHash</td><td>The hash of the previous accepted block's commit</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>DataHash</td><td>Correct hash of the block's Data field</td><td>checked in the `ValidateBasic()`` step</td></tr>
<tr><td>ConsensusHash</td><td>unused</td><td></td></tr>
<tr><td>AppHash</td><td>The correct state root after executing the block's transactions against the accepted state</td><td>checked during block execution</td></tr>
<tr><td>LastResultsHash</td><td>Correct results from executing transactions</td><td>checked during block execution</td></tr>
<tr><td>ProposerAddress</td><td>Address of the expected proposer</td><td>Must match Signer.Address in SignedHeader</td></tr>
<tr><td>ValidatorHash</td><td>Compatibility field for Tendermint light client</td><td>Not validated</td></tr>
</tbody></table>
</div>
<h2 id="signer"><a class="header" href="#signer"><a href="https://github.com/rollkit/rollkit/blob/main/types/signed_header.go">Signer</a></a></h2>
<p>The Signer type replaces the previous ValidatorSet for single sequencer operation:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>PubKey</td><td>Public key of the signer</td><td>Must not be nil if Signer is not empty</td></tr>
<tr><td>Address</td><td>Address derived from the public key</td><td>Must match ProposerAddress</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="da"><a class="header" href="#da">DA</a></h1>
<p>Rollkit provides a wrapper for <a href="https://github.com/rollkit/go-da">go-da</a>, a generic data availability interface for modular blockchains, called <code>DAClient</code> with wrapper functionalities like <code>SubmitBlocks</code> and <code>RetrieveBlocks</code> to help block manager interact with DA more easily.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p><code>DAClient</code> can connect via either gRPC or JSON-RPC transports using the <a href="https://github.com/rollkit/go-da">go-da</a> <a href="https://github.com/rollkit/go-da/tree/main/proxy/grpc">proxy/grpc</a> or <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">proxy/jsonrpc</a> implementations. The connection can be configured using the following cli flags:</p>
<ul>
<li><code>--rollkit.da_address</code>: url address of the DA service (default: &quot;grpc://localhost:26650&quot;)</li>
<li><code>--rollkit.da_auth_token</code>: authentication token of the DA service</li>
<li><code>--rollkit.da_namespace</code>: namespace to use when submitting blobs to the DA service</li>
</ul>
<p>Given a set of blocks to be submitted to DA by the block manager, the <code>SubmitBlocks</code> first encodes the blocks using protobuf (the encoded data are called blobs) and invokes the <code>Submit</code> method on the underlying DA implementation. On successful submission (<code>StatusSuccess</code>), the DA block height which included in the blocks is returned.</p>
<p>To make sure that the serialised blocks don't exceed the underlying DA's blob limits, it fetches the blob size limit by calling <code>Config</code> which returns the limit as <code>uint64</code> bytes, then includes serialised blocks until the limit is reached. If the limit is reached, it submits the partial set and returns the count of successfully submitted blocks as <code>SubmittedCount</code>. The caller should retry with the remaining blocks until all the blocks are submitted. If the first block itself is over the limit, it throws an error.</p>
<p>The <code>Submit</code> call may result in an error (<code>StatusError</code>) based on the underlying DA implementations on following scenarios:</p>
<ul>
<li>the total blobs size exceeds the underlying DA's limits (includes empty blobs)</li>
<li>the implementation specific failures, e.g., for <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">celestia-da-json-rpc</a>, invalid namespace, unable to create the commitment or proof, setting low gas price, etc, could return error.</li>
</ul>
<p>The <code>RetrieveBlocks</code> retrieves the blocks for a given DA height using <a href="https://github.com/rollkit/go-da">go-da</a> <code>GetIDs</code> and <code>Get</code> methods. If there are no blocks available for a given DA height, <code>StatusNotFound</code> is returned (which is not an error case). The retrieved blobs are converted back to blocks and returned on successful retrieval.</p>
<p>Both <code>SubmitBlocks</code> and <code>RetrieveBlocks</code> may be unsuccessful if the DA node and the DA blockchain that the DA implementation is using have failures. For example, failures such as, DA mempool is full, DA submit transaction is nonce clashing with other transaction from the DA submitter account, DA node is not synced, etc.</p>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/da/jsonrpc/client.go">da implementation</a></p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/go-da">go-da</a></p>
<p>[2] <a href="https://github.com/rollkit/go-da/tree/main/proxy/grpc">proxy/grpc</a></p>
<p>[3] <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">proxy/jsonrpc</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-node"><a class="header" href="#full-node">Full Node</a></h1>
<h2 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h2>
<p>A Full Node is a top-level service that encapsulates different components of Rollkit and initializes/manages them.</p>
<h2 id="details-1"><a class="header" href="#details-1">Details</a></h2>
<h3 id="full-node-details"><a class="header" href="#full-node-details">Full Node Details</a></h3>
<p>A Full Node is initialized inside the Cosmos SDK start script along with the node configuration, a private key to use in the P2P client, a private key for signing blocks as a block proposer, a client creator, a genesis document, and a logger. It uses them to initialize the components described above. The components TxIndexer, BlockIndexer, and IndexerService exist to ensure cometBFT compatibility since they are needed for most of the RPC calls from the <code>SignClient</code> interface from cometBFT.</p>
<p>Note that unlike a light node which only syncs and stores block headers seen on the P2P layer, the full node also syncs and stores full blocks seen on both the P2P network and the DA layer. Full blocks contain all the transactions published as part of the block.</p>
<p>The Full Node mainly encapsulates and initializes/manages the following components:</p>
<h3 id="genesisdoc"><a class="header" href="#genesisdoc">genesisDoc</a></h3>
<p>The <a href="https://github.com/cometbft/cometbft/blob/main/spec/core/genesis.md">genesis</a> document contains information about the initial state of the chain, in particular its validator set.</p>
<h3 id="conf"><a class="header" href="#conf">conf</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/config/config.go">node configuration</a> contains all the necessary settings for the node to be initialized and function properly.</p>
<h3 id="p2p"><a class="header" href="#p2p">P2P</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">peer-to-peer client</a> is used to gossip transactions between full nodes in the network.</p>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Store</a> is initialized with <code>DefaultStore</code>, an implementation of the <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go">store interface</a> which is used for storing and retrieving blocks, commits, and state. |</p>
<h3 id="blockmanager"><a class="header" href="#blockmanager">blockManager</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a> is responsible for managing block-related operations including:</p>
<ul>
<li>Block production (normal and lazy modes)</li>
<li>Header and data submission to DA layer</li>
<li>Block retrieval and synchronization</li>
<li>State updates and finalization</li>
</ul>
<p>It implements a header/data separation architecture where headers and transaction data are handled independently.</p>
<h3 id="dalc"><a class="header" href="#dalc">dalc</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/core/da/da.go">Data Availability Layer Client</a> is used to interact with the data availability layer. It is initialized with the DA Layer and DA Config specified in the node configuration.</p>
<h3 id="hsyncservice"><a class="header" href="#hsyncservice">hSyncService</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Header Sync Service</a> is used for syncing signed headers between nodes over P2P. It operates independently from data sync to support light clients.</p>
<h3 id="dsyncservice"><a class="header" href="#dsyncservice">dSyncService</a></h3>
<p>The [Data Sync Service] is used for syncing transaction data between nodes over P2P. This service is only used by full nodes, not light nodes.</p>
<h2 id="message-structurecommunication-format-2"><a class="header" href="#message-structurecommunication-format-2">Message Structure/Communication Format</a></h2>
<p>The Full Node communicates with other nodes in the network using the P2P client. It also communicates with the application using the ABCI proxy connections. The communication format is based on the P2P and ABCI protocols.</p>
<h2 id="assumptions-and-considerations-2"><a class="header" href="#assumptions-and-considerations-2">Assumptions and Considerations</a></h2>
<p>The Full Node assumes that the configuration, private keys, client creator, genesis document, and logger are correctly passed in by the Cosmos SDK. It also assumes that the P2P client, data availability layer client, block manager, and other services can be started and stopped without errors.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">full node</a></p>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[2] <a href="https://github.com/cometbft/cometbft/blob/main/spec/core/genesis.md">Genesis Document</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/config/config.go">Node Configuration</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">Peer to Peer Client</a></p>
<p>[5] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Store</a></p>
<p>[6] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go">Store Interface</a></p>
<p>[7] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[8] <a href="https://github.com/rollkit/rollkit/blob/main/core/da/da.go">Data Availability Layer Client</a></p>
<p>[9] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Header Sync Service</a></p>
<p>[10] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Block Sync Service</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-and-data-sync"><a class="header" href="#header-and-data-sync">Header and Data Sync</a></h1>
<h2 id="abstract-4"><a class="header" href="#abstract-4">Abstract</a></h2>
<p>The nodes in the P2P network sync headers and data using separate sync services that implement the <a href="https://github.com/celestiaorg/go-header">go-header</a> interface. Rollkit uses a header/data separation architecture where headers and transaction data are synchronized independently through parallel services. Each sync service consists of several components as listed below.</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td>store</td><td>a prefixed <a href="https://github.com/ipfs/go-datastore">datastore</a> where synced items are stored (<code>headerSync</code> prefix for headers, <code>dataSync</code> prefix for data)</td></tr>
<tr><td>subscriber</td><td>a <a href="https://github.com/libp2p/go-libp2p">libp2p</a> node pubsub subscriber for the specific data type</td></tr>
<tr><td>P2P server</td><td>a server for handling requests between peers in the P2P network</td></tr>
<tr><td>exchange</td><td>a client that enables sending in/out-bound requests from/to the P2P network</td></tr>
<tr><td>syncer</td><td>a service for efficient synchronization. When a P2P node falls behind and wants to catch up to the latest network head via P2P network, it can use the syncer.</td></tr>
</tbody></table>
</div>
<h2 id="details-2"><a class="header" href="#details-2">Details</a></h2>
<p>Rollkit implements two separate sync services:</p>
<h3 id="header-sync-service"><a class="header" href="#header-sync-service">Header Sync Service</a></h3>
<ul>
<li>Synchronizes <code>SignedHeader</code> structures containing block headers with signatures</li>
<li>Used by all node types (sequencer, full, and light)</li>
<li>Essential for maintaining the canonical view of the chain</li>
</ul>
<h3 id="data-sync-service"><a class="header" href="#data-sync-service">Data Sync Service</a></h3>
<ul>
<li>Synchronizes <code>Data</code> structures containing transaction data</li>
<li>Used only by full nodes and sequencers</li>
<li>Light nodes do not run this service as they only need headers</li>
</ul>
<p>Both services:</p>
<ul>
<li>Utilize the generic <code>SyncService[H header.Header[H]]</code> implementation</li>
<li>Inherit the <code>ConnectionGater</code> from the node's P2P client for peer management</li>
<li>Use <code>NodeConfig.BlockTime</code> to determine outdated items during sync</li>
<li>Operate independently on separate P2P topics and datastores</li>
</ul>
<h3 id="consumption-of-sync-services"><a class="header" href="#consumption-of-sync-services">Consumption of Sync Services</a></h3>
<h4 id="header-sync"><a class="header" href="#header-sync">Header Sync</a></h4>
<ul>
<li>Sequencer nodes publish signed headers to the P2P network after block creation</li>
<li>Full and light nodes receive and store headers for chain validation</li>
<li>Headers contain commitments (DataHash) that link to the corresponding data</li>
</ul>
<h4 id="data-sync"><a class="header" href="#data-sync">Data Sync</a></h4>
<ul>
<li>Sequencer nodes publish transaction data separately from headers</li>
<li>Only full nodes receive and store data (light nodes skip this)</li>
<li>Data is linked to headers through the DataHash commitment</li>
</ul>
<h4 id="parallel-broadcasting"><a class="header" href="#parallel-broadcasting">Parallel Broadcasting</a></h4>
<p>The block manager broadcasts headers and data in parallel when publishing blocks:</p>
<ul>
<li>Headers are sent through <code>headerBroadcaster</code></li>
<li>Data is sent through <code>dataBroadcaster</code></li>
<li>This enables efficient network propagation of both components</li>
</ul>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<ul>
<li>Separate datastores are created with different prefixes:
<ul>
<li>Headers: <code>headerSync</code> prefix on the main datastore</li>
<li>Data: <code>dataSync</code> prefix on the main datastore</li>
</ul>
</li>
<li>Network IDs are suffixed to distinguish services:
<ul>
<li>Header sync: <code>{network}-headerSync</code></li>
<li>Data sync: <code>{network}-dataSync</code></li>
</ul>
</li>
<li>Chain IDs for pubsub topics are also separated:
<ul>
<li>Headers: <code>{chainID}-headerSync</code> creates topic like <code>/gm-headerSync/header-sub/v0.0.1</code></li>
<li>Data: <code>{chainID}-dataSync</code> creates topic like <code>/gm-dataSync/header-sub/v0.0.1</code></li>
</ul>
</li>
<li>Both stores must be initialized with genesis items before starting:
<ul>
<li>Header store needs genesis header</li>
<li>Data store needs genesis data (if applicable)</li>
</ul>
</li>
<li>Genesis items can be loaded via <code>NodeConfig.TrustedHash</code> or P2P network query</li>
<li>Sync services work only when connected to P2P network via <code>P2PConfig.Seeds</code></li>
<li>Node context is passed to all components for graceful shutdown</li>
<li>Headers and data are linked through DataHash but synced independently</li>
</ul>
<h2 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h2>
<p>The sync service implementation can be found in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">pkg/sync/sync_service.go</a>. The generic <code>SyncService[H header.Header[H]]</code> is instantiated as:</p>
<ul>
<li><code>HeaderSyncService</code> for syncing <code>*types.SignedHeader</code></li>
<li><code>DataSyncService</code> for syncing <code>*types.Data</code></li>
</ul>
<p>Full nodes create and start both services, while light nodes only start the header sync service. The services are created in <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">full</a> and <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go">light</a> node implementations.</p>
<p>The block manager integrates with both services through:</p>
<ul>
<li><code>HeaderStoreRetrieveLoop()</code> for retrieving headers from P2P</li>
<li><code>DataStoreRetrieveLoop()</code> for retrieving data from P2P</li>
<li>Separate broadcast channels for publishing headers and data</li>
</ul>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Header Sync</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go">Light Node</a></p>
<p>[4] <a href="https://github.com/celestiaorg/go-header">go-header</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-and-data-separation-adr"><a class="header" href="#header-and-data-separation-adr">Header and Data Separation ADR</a></h1>
<h2 id="abstract-5"><a class="header" href="#abstract-5">Abstract</a></h2>
<p>The separation of header and data structures in Rollkit unlocks expanding the sequencing scheme beyond single sequencing and unlocks the use of a decentralized sequencer mode. This means that the creation of list of the transactions can be done by another network as well while nodes still produce headers after executing that list of transactions. This overall change is akin to the proposer-builder separation in the Ethereum protocol, where the Rollkit header producer acts as the proposer, and the sequencer, which produces a list of transactions, acts as the builder.</p>
<h3 id="before-separation"><a class="header" href="#before-separation">Before Separation</a></h3>
<pre><code class="language-mermaid">flowchart LR
    CS[Single Sequencer] --&gt;|Creates| B[Block]
    B --&gt;|Contains| SH1[SignedHeader]
    B --&gt;|Contains| D1[Data]

    class CS,B,SH1,D1 node
</code></pre>
<h3 id="after-separation"><a class="header" href="#after-separation">After Separation</a></h3>
<pre><code class="language-mermaid">flowchart LR
    HP[Header Producer] --&gt;|Creates| SH2[SignedHeader]
    SEQ[Sequencer] --&gt;|Creates| D2[Data]
    SH2 -.-&gt;|References via DataCommitment| D2

    class HP,SEQ,SH2,D2 node
</code></pre>
<h2 id="protocolcomponent-description-2"><a class="header" href="#protocolcomponent-description-2">Protocol/Component Description</a></h2>
<p>Before, Rollkit only supported the use of a single sequencer that was responsible for creating a list of transactions by reaping its mempool, executing them to produce a header, and putting them together in a block. Rollkit headers and data were encapsulated within a single block structure. The block struct looked like this:</p>
<pre><code class="language-go">// Block defines the structure of Rollkit block.
type Block struct {
	SignedHeader SignedHeader
	Data         Data
}
</code></pre>
<p>The separation of header and data into distinct structures allows them to be processed independently. The <code>SignedHeader</code> struct now focuses on the header information, while the <code>Data</code> struct handles transaction data separately. This separation is particularly beneficial in unlocking based sequencing, where users submit transactions directly to the Data Availability layer which acts as the entity responsible for creating the list of transactions.</p>
<pre><code class="language-mermaid">classDiagram
    class Block {
        SignedHeader
        Data
    }

    class SignedHeader {
        Header
        Signature
    }

    class Header {
        ParentHash
        Height
        Timestamp
        ChainID
        DataCommitment
        StateRoot
        ExtraData
    }

    class Data {
        Metadata
        Txs
    }

    Block *-- SignedHeader
    Block *-- Data
    SignedHeader *-- Header
</code></pre>
<p>This change also affects how full nodes sync. Previously, full nodes would apply the transactions from the <code>Block</code> struct and verify that the <code>header</code> in <code>SignedHeader</code> matched their locally produced header. Now, with the separation, full nodes obtain the transaction data separately (via the DA layer directly in based sequencer mode, or via p2p gossip/DA layer in single sequencer mode) and verify it against the header signed by the header producer once they have both components. If a full node receives the header/data via a p2p gossip layer, they should wait to see the same header/data on the DA layer before marking the corresponding block as finalized in their view.</p>
<p>This ensures that the data integrity and consistency are maintained across the network.</p>
<pre><code class="language-go">// SignedHeader struct consists of the header and a signature
type SignedHeader struct {
    Header // Rollkit Header
    Signature  Signature // Signature of the header producer
    ...
}

// Header struct focusing on header information
type Header struct {
    // Hash of the previous block header.
    ParentHash Hash
    // Height represents the block height (aka block number) of a given header
    Height uint64
    // Block creation timestamp
    Timestamp uint64
    // The Chain ID
    ChainID string
    // Pointer to location of associated block data aka transactions in the DA layer
    DataCommitment Hash
    // Commitment representing the state linked to the header
    StateRoot Hash
    // Arbitrary field for additional metadata
    ExtraData []byte
}

// Data defines Rollkit block data.
type Data struct {
	*Metadata // Defines metadata for Data struct to help with p2p gossiping.
	Txs Txs // List of transactions to be executed
}
</code></pre>
<p>The <code>publishBlock</code> method in <code>manager.go</code> now creates the header and data structures separately. This decoupling allows for the header to be submitted to the DA layer independently of the block data, which can be built by a separate network. This change supports the transition from a single sequencer mode to a decentralized sequencer mode, making the system more modular.</p>
<h2 id="message-structurecommunication-format-3"><a class="header" href="#message-structurecommunication-format-3">Message Structure/Communication Format</a></h2>
<h3 id="header-producer"><a class="header" href="#header-producer">Header Producer</a></h3>
<p>Before the separation: Only the entire <code>Block</code> struct composed of both header and data was submitted to the DA layer. The <code>Block</code> and <code>SignedHeader</code> were both gossipped over two separate p2p layers: gossipping <code>Block</code> to just full nodes and gossipping the <code>SignedHeader</code> to full nodes and future light nodes to join that will only sync headers (and proofs).</p>
<p>After the separation: The <code>SignedHeader</code> and <code>Data</code> are submitted separately to the DA layer. Note that the <code>SignedHeader</code> has a <code>Header</code> that is linked to the <code>Data</code> via a <code>DataCommitment</code> from the DA layer. <code>SignedHeader</code> and <code>Data</code> are both gossipped over two separate p2p layers: gossipping <code>Data</code> to just full nodes and gossipping the <code>SignedHeader</code> to full nodes and future light nodes to join that will only sync headers (and proofs).</p>
<p>In based sequencing mode, the header producer is equivalent to a full node.</p>
<h3 id="before-separation-1"><a class="header" href="#before-separation-1">Before Separation</a></h3>
<pre><code class="language-mermaid">flowchart LR

    CS1[Single Sequencer] --&gt;|Submits Block| DA1[DA Layer]
    CS1 --&gt;|Gossips Block| FN1[Full Nodes]
    CS1 --&gt;|Gossips SignedHeader| LN1[Light Nodes]

    class CS1,DA1,FN1,LN1 node
</code></pre>
<h3 id="after-separation---single-sequencer-mode"><a class="header" href="#after-separation---single-sequencer-mode">After Separation - Single Sequencer Mode</a></h3>
<pre><code class="language-mermaid">flowchart LR

    CS2[Single Sequencer] --&gt;|Submits Data| DA2[DA Layer]
    HP2[Header Producer] --&gt;|Submits SignedHeader| DA2

    CS2 --&gt;|Gossips Data| FN2[Full Nodes]
    HP2 --&gt;|Gossips SignedHeader| FN2
    HP2 --&gt;|Gossips SignedHeader| LN2[Light Nodes]

    class CS2,HP2,DA2,FN2,LN2 node
</code></pre>
<h3 id="after-separation---based-mode"><a class="header" href="#after-separation---based-mode">After Separation - Based Mode</a></h3>
<pre><code class="language-mermaid">flowchart LR

    Users --&gt;|Submit Txs| DA3[DA Layer]
    FN3[Full Node/Header Producer] --&gt;|Reads Data| DA3

    class Users,DA3,FN3,LN3 node
</code></pre>
<h3 id="syncing-full-node"><a class="header" href="#syncing-full-node">Syncing Full Node</a></h3>
<p>Before the separation: Full Nodes get the entire <code>Block</code> struct via p2p or the DA layer. They can choose to apply the block as soon as they get it via p2p OR just wait to see it on the DA layer. This depends on whether a full node opts in to the p2p layer or not. Gossipping the <code>SignedHeader</code> over p2p is primarily for light nodes to get the header.</p>
<p>After the separation: Full nodes get the <code>Data</code> struct and the <code>SignedHeader</code> struct separately over p2p and DA layers. In code, this refers to the <code>HeaderStore</code> and the <code>DataStore</code> in block manager. A Full node should wait for having both the <code>Data</code> struct and the corresponding <code>SignedHeader</code> to it before applying the block data to its associated state machine. This is so that the full node can verify that its locally produced header's state commitment after it applies the <code>Data</code> associated to a block is consistent with the <code>Header</code> inside the <code>SignedHeader</code> that is received from the header producer. The <code>Header</code> should contain a link to its associated Data via a <code>DataCommitment</code> that is a pointer to the location of the <code>Data</code> on the DA layer.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant FN as Full Node
    participant P2P as P2P Network
    participant DA as DA Layer
    participant SM as State Machine

    Note over FN,DA: After Separation - Sync Process

    P2P-&gt;&gt;FN: Receive Data
    P2P-&gt;&gt;FN: Receive SignedHeader
    FN-&gt;&gt;DA: Verify Data availability
    FN-&gt;&gt;DA: Verify SignedHeader availability
    FN-&gt;&gt;FN: Match Data with SignedHeader via DataCommitment
    FN-&gt;&gt;SM: Apply Data to state machine
    FN-&gt;&gt;FN: Verify locally produced header matches received Header
    FN-&gt;&gt;FN: Mark block as finalized
</code></pre>
<p>In a single sequencer mode, before, a full node marks a block finalized, it should verify that both the <code>SignedHeader</code> and <code>Data</code> associated to it were made available on the DA layer by checking it directly or verifying DA inclusion proofs.</p>
<p>In based sequencing mode, blocks can be instantly finalized since the <code>Data</code> is directly always derived from the DA layer and already exists there. There's no need for a <code>SignedHeader</code> to exist on the DA layer.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant DA as DA Layer
    participant FN as Full Node
    participant SM as State Machine

    Note over DA,FN: Based Sequencing Mode

    DA-&gt;&gt;FN: Data already available
    FN-&gt;&gt;FN: Read Data from DA
    FN-&gt;&gt;FN: Execute transactions
    FN-&gt;&gt;FN: Produce Header
    FN-&gt;&gt;SM: Apply state changes
    FN-&gt;&gt;FN: Finalize Block
    Note right of FN: No need to submit SignedHeader to DA
</code></pre>
<h2 id="assumptions-and-considerations-3"><a class="header" href="#assumptions-and-considerations-3">Assumptions and Considerations</a></h2>
<ul>
<li>Considerations include ensuring that headers and data are correctly synchronized and validated to prevent inconsistencies.</li>
<li>Ensure that all components interacting with headers and data are updated to handle them as separate entities.</li>
<li>Security measures should be in place to prevent unauthorized access or tampering with headers and data during transmission and storage.</li>
<li>Performance optimizations may be necessary to handle the increased complexity of managing separate header and data structures, especially in high-throughput environments.</li>
<li>Testing and validation processes should be updated to account for the new structure and ensure that all components function correctly in both single and decentralized sequencer modes.</li>
</ul>
<h2 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h2>
<p>The implementation of this separation can be found in the Rollkit repository, specifically in the changes made to the <code>manager.go</code> file. The <code>publishBlock</code> method illustrates the creation of separate header and data structures, and the associated logic for handling them independently. See <a href="https://github.com/rollkit/rollkit/pull/1789">Rollkit PR #1789</a></p>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><a href="https://github.com/rollkit/rollkit/pull/1789">Rollkit PR #1789</a></li>
<li><a href="https://www.alchemy.com/overviews/proposer-builder-separation">Proposer-Builder Separation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollkit-minimal-header"><a class="header" href="#rollkit-minimal-header">Rollkit Minimal Header</a></h1>
<h2 id="abstract-6"><a class="header" href="#abstract-6">Abstract</a></h2>
<p>This document specifies a minimal header format for Rollkit, designed to eliminate the dependency on CometBFT's header format. This new format can then be used to produce an execution layer tailored header if needed. For example, the new ABCI Execution layer can have an ABCI-specific header for IBC compatibility. This allows Rollkit to define its own header structure while maintaining backward compatibility where necessary.</p>
<h2 id="protocolcomponent-description-3"><a class="header" href="#protocolcomponent-description-3">Protocol/Component Description</a></h2>
<p>The Rollkit minimal header is a streamlined version of the traditional header, focusing on essential information required for block processing and state management for nodes. This header format is designed to be lightweight and efficient, facilitating faster processing and reduced overhead.</p>
<h3 id="rollkit-minimal-header-structure"><a class="header" href="#rollkit-minimal-header-structure">Rollkit Minimal Header Structure</a></h3>
<pre><code class="language-ascii">┌─────────────────────────────────────────────┐
│             Rollkit Minimal Header          │
├─────────────────────┬───────────────────────┤
│ ParentHash          │ Hash of previous block│
├─────────────────────┼───────────────────────┤
│ Height              │ Block number          │
├─────────────────────┼───────────────────────┤
│ Timestamp           │ Creation time         │
├─────────────────────┼───────────────────────┤
│ ChainID             │ Chain identifier      │
├─────────────────────┼───────────────────────┤
│ DataCommitment      │ Pointer to block data │
│                     │ on DA layer           │
├─────────────────────┼───────────────────────┤
│ StateRoot           │ State commitment      │
├─────────────────────┼───────────────────────┤
│ ExtraData           │ Additional metadata   │
│                     │ (e.g. sequencer info) │
└─────────────────────┴───────────────────────┘
</code></pre>
<h2 id="message-structurecommunication-format-4"><a class="header" href="#message-structurecommunication-format-4">Message Structure/Communication Format</a></h2>
<p>The header is defined in GoLang as follows:</p>
<pre><code class="language-go">// Header struct focusing on header information
type Header struct {
    // Hash of the previous block header.
    ParentHash Hash
    // Height represents the block height (aka block number) of a given header
    Height uint64
    // Block creation timestamp
    Timestamp uint64
    // The Chain ID
    ChainID string
    // Pointer to location of associated block data aka transactions in the DA layer
    DataCommitment []byte
    // Commitment representing the state linked to the header
    StateRoot Hash
    // Arbitrary field for additional metadata
    ExtraData []byte
}
</code></pre>
<p>In case the chain has a specific designated proposer or a proposer set, that information can be put in the <code>extraData</code> field. So in single sequencer mode, the <code>sequencerAddress</code> can live in <code>extraData</code>. For base sequencer mode, this information is not relevant.</p>
<p>This minimal Rollkit header can be transformed to be tailored to a specific execution layer as well by inserting additional information typically needed.</p>
<h3 id="evm-execution-client"><a class="header" href="#evm-execution-client">EVM execution client</a></h3>
<ul>
<li><code>transactionsRoot</code>: Merkle root of all transactions in the block. Can be constructed from unpacking the <code>DataCommitment</code> in Rollkit Header.</li>
<li><code>receiptsRoot</code>: Merkle root of all transaction receipts, which store the results of transaction execution. This can be inserted by the EVM execution client.</li>
<li><code>Gas Limit</code>: Max gas allowed in the block.</li>
<li><code>Gas Used</code>: Total gas consumed in this block.</li>
</ul>
<h4 id="transformation-to-evm-header"><a class="header" href="#transformation-to-evm-header">Transformation to EVM Header</a></h4>
<pre><code class="language-ascii">┌─────────────────────────────────────────────┐
│             Rollkit Minimal Header          │
└───────────────────┬─────────────────────────┘
                    │
                    ▼ Transform
┌─────────────────────────────────────────────┐
│               EVM Header                    │
├─────────────────────┬───────────────────────┤
│ ParentHash          │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ Height/Number       │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ Timestamp           │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ ChainID             │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ TransactionsRoot    │ Derived from          │
│                     │ DataCommitment        │
├─────────────────────┼───────────────────────┤
│ StateRoot           │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ ReceiptsRoot        │ Added by EVM client   │
├─────────────────────┼───────────────────────┤
│ GasLimit            │ Added by EVM client   │
├─────────────────────┼───────────────────────┤
│ GasUsed             │ Added by EVM client   │
├─────────────────────┼───────────────────────┤
│ ExtraData           │ From Rollkit Header   │
└─────────────────────┴───────────────────────┘
</code></pre>
<h3 id="abci-execution"><a class="header" href="#abci-execution">ABCI Execution</a></h3>
<p>This header can be transformed into an ABCI-specific header for IBC compatibility.</p>
<ul>
<li><code>Version</code>: Required by IBC clients to correctly interpret the block's structure and contents.</li>
<li><code>LastCommitHash</code>: The hash of the previous block's commit, used by IBC clients to verify the legitimacy of the block's state transitions.</li>
<li><code>DataHash</code>: A hash of the block's transaction data, enabling IBC clients to verify that the data has not been tampered with. Can be constructed from unpacking the <code>DataCommitment</code> in Rollkit header.</li>
<li><code>ValidatorHash</code>: Current validator set's hash, which IBC clients use to verify that the block was validated by the correct set of validators. This can be the IBC attester set of the chain for backward compatibility with the IBC Tendermint client, if needed.</li>
<li><code>NextValidatorsHash</code>: The hash of the next validator set, allowing IBC clients to anticipate and verify upcoming validators.</li>
<li><code>ConsensusHash</code>: Denotes the hash of the consensus parameters, ensuring that IBC clients are aligned with the consensus rules of the blockchain.</li>
<li><code>AppHash</code>: Same as the <code>StateRoot</code> in the Rollkit Header.</li>
<li><code>EvidenceHash</code>: A hash of evidence of any misbehavior by validators, which IBC clients use to assess the trustworthiness of the validator set.</li>
<li><code>LastResultsHash</code>: Root hash of all results from the transactions from the previous block.</li>
<li><code>ProposerAddress</code>: The address of the block proposer, allowing IBC clients to track and verify the entities proposing new blocks. Can be constructed from the <code>extraData</code> field in the Rollkit Header.</li>
</ul>
<h4 id="transformation-to-abci-header"><a class="header" href="#transformation-to-abci-header">Transformation to ABCI Header</a></h4>
<pre><code class="language-ascii">┌─────────────────────────────────────────────┐
│             Rollkit Minimal Header          │
└───────────────────┬─────────────────────────┘
                    │
                    ▼ Transform
┌─────────────────────────────────────────────┐
│               ABCI Header                   │
├─────────────────────┬───────────────────────┤
│ Height              │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ Time                │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ ChainID             │ From Rollkit Header   │
├─────────────────────┼───────────────────────┤
│ AppHash             │ From StateRoot        │
├─────────────────────┼───────────────────────┤
│ DataHash            │ From DataCommitment   │
├─────────────────────┼───────────────────────┤
│ Version             │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ LastCommitHash      │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ ValidatorHash       │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ NextValidatorsHash  │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ ConsensusHash       │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ EvidenceHash        │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ LastResultsHash     │ Added for IBC         │
├─────────────────────┼───────────────────────┤
│ ProposerAddress     │ From ExtraData        │
└─────────────────────┴───────────────────────┘
</code></pre>
<h2 id="assumptions-and-considerations-4"><a class="header" href="#assumptions-and-considerations-4">Assumptions and Considerations</a></h2>
<ul>
<li>The Rollkit minimal header is designed to be flexible and adaptable, allowing for integration with various execution layers such as EVM and ABCI, without being constrained by CometBFT's header format.</li>
<li>The <code>extraData</code> field provides a mechanism for including additional metadata, such as sequencer information, which can be crucial for certain chain configurations.</li>
<li>The transformation of the Rollkit header into execution layer-specific headers should be done carefully to ensure compatibility and correctness, especially for IBC and any other cross-chain communication protocols.</li>
</ul>
<h3 id="header-transformation-flow"><a class="header" href="#header-transformation-flow">Header Transformation Flow</a></h3>
<pre><code class="language-ascii">┌─────────────────────────────────────────────┐
│             Rollkit Minimal Header          │
│                                             │
│  A lightweight, flexible header format      │
│  with essential fields for block processing │
└───────────┬─────────────────┬───────────────┘
            │                 │
            ▼                 ▼
┌───────────────────┐ ┌─────────────────────┐
│  EVM Header       │ │  ABCI Header        │
│                   │ │                     │
│  For EVM-based    │ │  For IBC-compatible │
│  execution layers │ │  execution layers   │
└───────────────────┘ └─────────────────────┘
</code></pre>
<h2 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h2>
<p>Pending implementation.</p>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><a href="https://ethereum.org/en/developers/docs/">Ethereum Developer Documentation</a>: Comprehensive resources for understanding Ethereum's architecture, including block and transaction structures.</li>
<li><a href="https://docs.tendermint.com/master/spec/">Tendermint Core Documentation</a>: Detailed documentation on Tendermint, which includes information on ABCI and its header format.</li>
<li><a href="https://github.com/tendermint/spec/blob/master/spec/abci/abci.md">ABCI Specification</a>: The official specification for the Application Blockchain Interface (ABCI), which describes how applications can interact with the Tendermint consensus engine.</li>
<li><a href="https://github.com/cosmos/ibc">IBC Protocol Specification</a>: Documentation on the Inter-Blockchain Communication (IBC) protocol, which includes details on how headers are used for cross-chain communication.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="p2p-1"><a class="header" href="#p2p-1">P2P</a></h1>
<p>Every  node (both full and light) runs a P2P client using <a href="https://github.com/libp2p/go-libp2p">go-libp2p</a> P2P networking stack for gossiping transactions in the chain's P2P network. The same P2P client is also used by the header and block sync services for gossiping headers and blocks.</p>
<p>Following parameters are required for creating a new instance of a P2P client:</p>
<ul>
<li>P2PConfig (described below)</li>
<li><a href="https://github.com/libp2p/go-libp2p">go-libp2p</a> private key used to create a libp2p connection and join the p2p network.</li>
<li>chainID: identifier used as namespace within the p2p network for peer discovery. The namespace acts as a sub network in the p2p network, where peer connections are limited to the same namespace.</li>
<li>datastore: an instance of <a href="https://github.com/ipfs/go-datastore">go-datastore</a> used for creating a connection gator and stores blocked and allowed peers.</li>
<li>logger</li>
</ul>
<pre><code class="language-go">// P2PConfig stores configuration related to peer-to-peer networking.
type P2PConfig struct {
	ListenAddress string // Address to listen for incoming connections
	Seeds         string // Comma separated list of seed nodes to connect to
	BlockedPeers  string // Comma separated list of nodes to ignore
	AllowedPeers  string // Comma separated list of nodes to whitelist
}
</code></pre>
<p>A P2P client also instantiates a <a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/net/conngater">connection gator</a> to block and allow peers specified in the <code>P2PConfig</code>.</p>
<p>It also sets up a gossiper using the gossip topic <code>&lt;chainID&gt;+&lt;txTopicSuffix&gt;</code> (<code>txTopicSuffix</code> is defined in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">p2p/client.go</a>), a Distributed Hash Table (DHT) using the <code>Seeds</code> defined in the <code>P2PConfig</code> and peer discovery using go-libp2p's <code>discovery.RoutingDiscovery</code>.</p>
<p>A P2P client provides an interface <code>SetTxValidator(p2p.GossipValidator)</code> for specifying a gossip validator which can define how to handle the incoming <code>GossipMessage</code> in the P2P network. The <code>GossipMessage</code> represents message gossiped via P2P network (e.g. transaction, Block etc).</p>
<pre><code class="language-go">// GossipValidator is a callback function type.
type GossipValidator func(*GossipMessage) bool
</code></pre>
<p>The full nodes define a transaction validator (shown below) as gossip validator for processing the gossiped transactions to add to the mempool, whereas light nodes simply pass a dummy validator as light nodes do not process gossiped transactions.</p>
<pre><code class="language-go">// newTxValidator creates a pubsub validator that uses the node's mempool to check the
// transaction. If the transaction is valid, then it is added to the mempool
func (n *FullNode) newTxValidator() p2p.GossipValidator {
</code></pre>
<pre><code class="language-go">// Dummy validator that always returns a callback function with boolean `false`
func (ln *LightNode) falseValidator() p2p.GossipValidator {
</code></pre>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">client.go</a></p>
<p>[2] <a href="https://github.com/ipfs/go-datastore">go-datastore</a></p>
<p>[3] <a href="https://github.com/libp2p/go-libp2p">go-libp2p</a></p>
<p>[4] <a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/net/conngater">conngater</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-1"><a class="header" href="#store-1">Store</a></h1>
<h2 id="abstract-7"><a class="header" href="#abstract-7">Abstract</a></h2>
<p>The Store interface defines methods for storing and retrieving blocks, commits, and the state of the blockchain.</p>
<h2 id="protocolcomponent-description-4"><a class="header" href="#protocolcomponent-description-4">Protocol/Component Description</a></h2>
<p>The Store interface defines the following methods:</p>
<ul>
<li><code>Height</code>: Returns the height of the highest block in the store.</li>
<li><code>SetHeight</code>: Sets given height in the store if it's higher than the existing height in the store.</li>
<li><code>SaveBlock</code>: Saves a block (containing both header and data) along with its seen signature.</li>
<li><code>GetBlock</code>: Returns a block at a given height.</li>
<li><code>GetBlockByHash</code>: Returns a block with a given block header hash.</li>
</ul>
<p>Note: While blocks are stored as complete units in the store, the block manager handles headers and data separately during synchronization and DA layer interaction.</p>
<ul>
<li><code>SaveBlockResponses</code>: Saves block responses in the Store.</li>
<li><code>GetBlockResponses</code>: Returns block results at a given height.</li>
<li><code>GetSignature</code>: Returns a signature for a block at a given height.</li>
<li><code>GetSignatureByHash</code>: Returns a signature for a block with a given block header hash.</li>
<li><code>UpdateState</code>: Updates the state saved in the Store. Only one State is stored.</li>
<li><code>GetState</code>: Returns the last state saved with UpdateState.</li>
<li><code>SaveValidators</code>: Saves the validator set at a given height.</li>
<li><code>GetValidators</code>: Returns the validator set at a given height.</li>
</ul>
<p>The <code>TxnDatastore</code> interface inside <a href="https://github.com/ipfs/go-datastore">go-datastore</a> is used for constructing different key-value stores for the underlying storage of a full node. The are two different implementations of <code>TxnDatastore</code> in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/kv.go">kv.go</a>:</p>
<ul>
<li>
<p><code>NewDefaultInMemoryKVStore</code>: Builds a key-value store that uses the <a href="https://github.com/dgraph-io/badger">BadgerDB</a> library and operates in-memory, without accessing the disk. Used only across unit tests and integration tests.</p>
</li>
<li>
<p><code>NewDefaultKVStore</code>: Builds a key-value store that uses the <a href="https://github.com/dgraph-io/badger">BadgerDB</a> library and stores the data on disk at the specified path.</p>
</li>
</ul>
<p>A Rollkit full node is <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">initialized</a> using <code>NewDefaultKVStore</code> as the base key-value store for underlying storage. To store various types of data in this base key-value store, different prefixes are used: <code>mainPrefix</code>, <code>dalcPrefix</code>, and <code>indexerPrefix</code>. The <code>mainPrefix</code> equal to <code>0</code> is used for the main node data, <code>dalcPrefix</code> equal to <code>1</code> is used for Data Availability Layer Client (DALC) data, and <code>indexerPrefix</code> equal to <code>2</code> is used for indexing related data.</p>
<p>For the main node data, <code>DefaultStore</code> struct, an implementation of the Store interface, is used with the following prefixes for various types of data within it:</p>
<ul>
<li><code>blockPrefix</code> with value &quot;b&quot;: Used to store complete blocks in the key-value store.</li>
<li><code>indexPrefix</code> with value &quot;i&quot;: Used to index the blocks stored in the key-value store.</li>
<li><code>commitPrefix</code> with value &quot;c&quot;: Used to store commits related to the blocks.</li>
<li><code>statePrefix</code> with value &quot;s&quot;: Used to store the state of the blockchain.</li>
<li><code>responsesPrefix</code> with value &quot;r&quot;: Used to store responses related to the blocks.</li>
<li><code>validatorsPrefix</code> with value &quot;v&quot;: Used to store validator sets at a given height.</li>
</ul>
<p>Additional prefixes used by sync services:</p>
<ul>
<li><code>headerSync</code>: Used by the header sync service for P2P synced headers.</li>
<li><code>dataSync</code>: Used by the data sync service for P2P synced transaction data.</li>
</ul>
<p>For example, in a call to <code>GetBlockByHash</code> for some block hash <code>&lt;block_hash&gt;</code>, the key used in the full node's base key-value store will be <code>/0/b/&lt;block_hash&gt;</code> where <code>0</code> is the main store prefix and <code>b</code> is the block prefix. Similarly, in a call to <code>GetValidators</code> for some height <code>&lt;height&gt;</code>, the key used in the full node's base key-value store will be <code>/0/v/&lt;height&gt;</code> where <code>0</code> is the main store prefix and <code>v</code> is the validator set prefix.</p>
<p>Inside the key-value store, the value of these various types of data like <code>Block</code> is stored as a byte array which is encoded and decoded using the corresponding Protobuf <a href="https://github.com/rollkit/rollkit/blob/main/types/serialization.go">marshal and unmarshal methods</a>.</p>
<p>The store is most widely used inside the <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">block manager</a> to perform their functions correctly. Within the block manager, since it has multiple go-routines in it, it is protected by a mutex lock, <code>lastStateMtx</code>, to synchronize read/write access to it and prevent race conditions.</p>
<h2 id="message-structurecommunication-format-5"><a class="header" href="#message-structurecommunication-format-5">Message Structure/Communication Format</a></h2>
<p>The Store does not communicate over the network, so there is no message structure or communication format.</p>
<h2 id="assumptions-and-considerations-5"><a class="header" href="#assumptions-and-considerations-5">Assumptions and Considerations</a></h2>
<p>The Store assumes that the underlying datastore is reliable and provides atomicity for transactions. It also assumes that the data passed to it for storage is valid and correctly formatted.</p>
<h2 id="implementation-7"><a class="header" href="#implementation-7">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go#L11">Store Interface</a> and <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Default Store</a> for its implementation.</p>
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go#L11">Store Interface</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Default Store</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">Full Node Store Initialization</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[5] <a href="https://github.com/dgraph-io/badger">Badger DB</a></p>
<p>[6] <a href="https://github.com/ipfs/go-datastore">Go Datastore</a></p>
<p>[7] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/kv.go">Key Value Store</a></p>
<p>[8 ] <a href="https://github.com/rollkit/rollkit/blob/main/types/serialization.go">Serialization</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
