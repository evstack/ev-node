import{_ as h,c as p,ag as l,b as r,w as s,af as o,j as t,a,B as c,o as i,G as d}from"./chunks/framework.CmpABV1Y.js";const b=JSON.parse('{"title":"Header and Data Separation ADR","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Header and Data Separation ADR | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"adr/adr-014-header-and-data-separation.md","filePath":"adr/adr-014-header-and-data-separation.md","lastUpdated":1755775229000}'),k={name:"adr/adr-014-header-and-data-separation.md"};function u(g,e,A,m,f,y){const n=c("Mermaid");return i(),p("div",null,[e[8]||(e[8]=l('<h1 id="header-and-data-separation-adr" tabindex="-1">Header and Data Separation ADR <a class="header-anchor" href="#header-and-data-separation-adr" aria-label="Permalink to &quot;Header and Data Separation ADR&quot;">​</a></h1><h2 id="abstract" tabindex="-1">Abstract <a class="header-anchor" href="#abstract" aria-label="Permalink to &quot;Abstract&quot;">​</a></h2><p>The separation of header and data structures in Rollkit unlocks expanding the sequencing scheme beyond single sequencing and unlocks the use of a decentralized sequencer mode. This means that the creation of list of the transactions can be done by another network as well while nodes still produce headers after executing that list of transactions. This overall change is akin to the proposer-builder separation in the Ethereum protocol, where the Rollkit header producer acts as the proposer, and the sequencer, which produces a list of transactions, acts as the builder.</p><h3 id="before-separation" tabindex="-1">Before Separation <a class="header-anchor" href="#before-separation" aria-label="Permalink to &quot;Before Separation&quot;">​</a></h3>',4)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-12",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20CS%5BSingle%20Sequencer%5D%20--%3E%7CCreates%7C%20B%5BBlock%5D%0A%20%20%20%20B%20--%3E%7CContains%7C%20SH1%5BSignedHeader%5D%0A%20%20%20%20B%20--%3E%7CContains%7C%20D1%5BData%5D%0A%0A%20%20%20%20class%20CS%2CB%2CSH1%2CD1%20node%0A"})]),fallback:s(()=>e[0]||(e[0]=[a(" Loading... ")])),_:1})),e[9]||(e[9]=t("h3",{id:"after-separation",tabindex:"-1"},[a("After Separation "),t("a",{class:"header-anchor",href:"#after-separation","aria-label":'Permalink to "After Separation"'},"​")],-1)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-16",class:"mermaid",graph:"flowchart%20LR%0A%20%20%20%20HP%5BHeader%20Producer%5D%20--%3E%7CCreates%7C%20SH2%5BSignedHeader%5D%0A%20%20%20%20SEQ%5BSequencer%5D%20--%3E%7CCreates%7C%20D2%5BData%5D%0A%20%20%20%20SH2%20-.-%3E%7CReferences%20via%20DataCommitment%7C%20D2%0A%0A%20%20%20%20class%20HP%2CSEQ%2CSH2%2CD2%20node%0A"})]),fallback:s(()=>e[1]||(e[1]=[a(" Loading... ")])),_:1})),e[10]||(e[10]=l(`<h2 id="protocol-component-description" tabindex="-1">Protocol/Component Description <a class="header-anchor" href="#protocol-component-description" aria-label="Permalink to &quot;Protocol/Component Description&quot;">​</a></h2><p>Before, Rollkit only supported the use of a single sequencer that was responsible for creating a list of transactions by reaping its mempool, executing them to produce a header, and putting them together in a block. Rollkit headers and data were encapsulated within a single block structure. The block struct looked like this:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Block defines the structure of Rollkit block.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Block</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	SignedHeader </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SignedHeader</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Data         </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The separation of header and data into distinct structures allows them to be processed independently. The <code>SignedHeader</code> struct now focuses on the header information, while the <code>Data</code> struct handles transaction data separately. This separation is particularly beneficial in unlocking based sequencing, where users submit transactions directly to the Data Availability layer which acts as the entity responsible for creating the list of transactions.</p>`,4)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-27",class:"mermaid",graph:"classDiagram%0A%20%20%20%20class%20Block%20%7B%0A%20%20%20%20%20%20%20%20SignedHeader%0A%20%20%20%20%20%20%20%20Data%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20SignedHeader%20%7B%0A%20%20%20%20%20%20%20%20Header%0A%20%20%20%20%20%20%20%20Signature%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20Header%20%7B%0A%20%20%20%20%20%20%20%20ParentHash%0A%20%20%20%20%20%20%20%20Height%0A%20%20%20%20%20%20%20%20Timestamp%0A%20%20%20%20%20%20%20%20ChainID%0A%20%20%20%20%20%20%20%20DataCommitment%0A%20%20%20%20%20%20%20%20StateRoot%0A%20%20%20%20%20%20%20%20ExtraData%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20Data%20%7B%0A%20%20%20%20%20%20%20%20Metadata%0A%20%20%20%20%20%20%20%20Txs%0A%20%20%20%20%7D%0A%0A%20%20%20%20Block%20*--%20SignedHeader%0A%20%20%20%20Block%20*--%20Data%0A%20%20%20%20SignedHeader%20*--%20Header%0A"})]),fallback:s(()=>e[2]||(e[2]=[a(" Loading... ")])),_:1})),e[11]||(e[11]=l(`<p>This change also affects how full nodes sync. Previously, full nodes would apply the transactions from the <code>Block</code> struct and verify that the <code>header</code> in <code>SignedHeader</code> matched their locally produced header. Now, with the separation, full nodes obtain the transaction data separately (via the DA layer directly in based sequencer mode, or via p2p gossip/DA layer in single sequencer mode) and verify it against the header signed by the header producer once they have both components. If a full node receives the header/data via a p2p gossip layer, they should wait to see the same header/data on the DA layer before marking the corresponding block as finalized in their view.</p><p>This ensures that the data integrity and consistency are maintained across the network.</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// SignedHeader struct consists of the header and a signature</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SignedHeader</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Header</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Rollkit Header</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Signature  </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Signature</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Signature of the header producer</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Header struct focusing on header information</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Header</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Hash of the previous block header.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ParentHash </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Hash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Height represents the block height (aka block number) of a given header</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Block creation timestamp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Timestamp </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // The Chain ID</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ChainID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Pointer to location of associated block data aka transactions in the DA layer</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    DataCommitment </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Hash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Commitment representing the state linked to the header</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    StateRoot </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Hash</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Arbitrary field for additional metadata</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ExtraData []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Data defines Rollkit block data.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Metadata</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Defines metadata for Data struct to help with p2p gossiping.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Txs </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Txs</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // List of transactions to be executed</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The <code>publishBlock</code> method in <code>manager.go</code> now creates the header and data structures separately. This decoupling allows for the header to be submitted to the DA layer independently of the block data, which can be built by a separate network. This change supports the transition from a single sequencer mode to a decentralized sequencer mode, making the system more modular.</p><h2 id="message-structure-communication-format" tabindex="-1">Message Structure/Communication Format <a class="header-anchor" href="#message-structure-communication-format" aria-label="Permalink to &quot;Message Structure/Communication Format&quot;">​</a></h2><h3 id="header-producer" tabindex="-1">Header Producer <a class="header-anchor" href="#header-producer" aria-label="Permalink to &quot;Header Producer&quot;">​</a></h3><p>Before the separation: Only the entire <code>Block</code> struct composed of both header and data was submitted to the DA layer. The <code>Block</code> and <code>SignedHeader</code> were both gossipped over two separate p2p layers: gossiping <code>Block</code> to just full nodes and gossiping the <code>SignedHeader</code> to full nodes and future light nodes to join that will only sync headers (and proofs).</p><p>After the separation: The <code>SignedHeader</code> and <code>Data</code> are submitted separately to the DA layer. Note that the <code>SignedHeader</code> has a <code>Header</code> that is linked to the <code>Data</code> via a <code>DataCommitment</code> from the DA layer. <code>SignedHeader</code> and <code>Data</code> are both gossipped over two separate p2p layers: gossiping <code>Data</code> to just full nodes and gossiping the <code>SignedHeader</code> to full nodes and future light nodes to join that will only sync headers (and proofs).</p><p>In based sequencing mode, the header producer is equivalent to a full node.</p><h3 id="before-separation-1" tabindex="-1">Before Separation <a class="header-anchor" href="#before-separation-1" aria-label="Permalink to &quot;Before Separation&quot;">​</a></h3>`,10)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-56",class:"mermaid",graph:"flowchart%20LR%0A%0A%20%20%20%20CS1%5BSingle%20Sequencer%5D%20--%3E%7CSubmits%20Block%7C%20DA1%5BDA%20Layer%5D%0A%20%20%20%20CS1%20--%3E%7CGossips%20Block%7C%20FN1%5BFull%20Nodes%5D%0A%20%20%20%20CS1%20--%3E%7CGossips%20SignedHeader%7C%20LN1%5BLight%20Nodes%5D%0A%0A%20%20%20%20class%20CS1%2CDA1%2CFN1%2CLN1%20node%0A"})]),fallback:s(()=>e[3]||(e[3]=[a(" Loading... ")])),_:1})),e[12]||(e[12]=t("h3",{id:"after-separation-single-sequencer-mode",tabindex:"-1"},[a("After Separation - Single Sequencer Mode "),t("a",{class:"header-anchor",href:"#after-separation-single-sequencer-mode","aria-label":'Permalink to "After Separation - Single Sequencer Mode"'},"​")],-1)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-60",class:"mermaid",graph:"flowchart%20LR%0A%0A%20%20%20%20CS2%5BSingle%20Sequencer%5D%20--%3E%7CSubmits%20Data%7C%20DA2%5BDA%20Layer%5D%0A%20%20%20%20HP2%5BHeader%20Producer%5D%20--%3E%7CSubmits%20SignedHeader%7C%20DA2%0A%0A%20%20%20%20CS2%20--%3E%7CGossips%20Data%7C%20FN2%5BFull%20Nodes%5D%0A%20%20%20%20HP2%20--%3E%7CGossips%20SignedHeader%7C%20FN2%0A%20%20%20%20HP2%20--%3E%7CGossips%20SignedHeader%7C%20LN2%5BLight%20Nodes%5D%0A%0A%20%20%20%20class%20CS2%2CHP2%2CDA2%2CFN2%2CLN2%20node%0A"})]),fallback:s(()=>e[4]||(e[4]=[a(" Loading... ")])),_:1})),e[13]||(e[13]=t("h3",{id:"after-separation-based-mode",tabindex:"-1"},[a("After Separation - Based Mode "),t("a",{class:"header-anchor",href:"#after-separation-based-mode","aria-label":'Permalink to "After Separation - Based Mode"'},"​")],-1)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-64",class:"mermaid",graph:"flowchart%20LR%0A%0A%20%20%20%20Users%20--%3E%7CSubmit%20Txs%7C%20DA3%5BDA%20Layer%5D%0A%20%20%20%20FN3%5BFull%20Node%2FHeader%20Producer%5D%20--%3E%7CReads%20Data%7C%20DA3%0A%0A%20%20%20%20class%20Users%2CDA3%2CFN3%2CLN3%20node%0A"})]),fallback:s(()=>e[5]||(e[5]=[a(" Loading... ")])),_:1})),e[14]||(e[14]=l('<h3 id="syncing-full-node" tabindex="-1">Syncing Full Node <a class="header-anchor" href="#syncing-full-node" aria-label="Permalink to &quot;Syncing Full Node&quot;">​</a></h3><p>Before the separation: Full Nodes get the entire <code>Block</code> struct via p2p or the DA layer. They can choose to apply the block as soon as they get it via p2p OR just wait to see it on the DA layer. This depends on whether a full node opts in to the p2p layer or not. Gossiping the <code>SignedHeader</code> over p2p is primarily for light nodes to get the header.</p><p>After the separation: Full nodes get the <code>Data</code> struct and the <code>SignedHeader</code> struct separately over p2p and DA layers. In code, this refers to the <code>HeaderStore</code> and the <code>DataStore</code> in block manager. A Full node should wait for having both the <code>Data</code> struct and the corresponding <code>SignedHeader</code> to it before applying the block data to its associated state machine. This is so that the full node can verify that its locally produced header&#39;s state commitment after it applies the <code>Data</code> associated to a block is consistent with the <code>Header</code> inside the <code>SignedHeader</code> that is received from the header producer. The <code>Header</code> should contain a link to its associated Data via a <code>DataCommitment</code> that is a pointer to the location of the <code>Data</code> on the DA layer.</p>',3)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-74",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20FN%20as%20Full%20Node%0A%20%20%20%20participant%20P2P%20as%20P2P%20Network%0A%20%20%20%20participant%20DA%20as%20DA%20Layer%0A%20%20%20%20participant%20SM%20as%20State%20Machine%0A%0A%20%20%20%20Note%20over%20FN%2CDA%3A%20After%20Separation%20-%20Sync%20Process%0A%0A%20%20%20%20P2P-%3E%3EFN%3A%20Receive%20Data%0A%20%20%20%20P2P-%3E%3EFN%3A%20Receive%20SignedHeader%0A%20%20%20%20FN-%3E%3EDA%3A%20Verify%20Data%20availability%0A%20%20%20%20FN-%3E%3EDA%3A%20Verify%20SignedHeader%20availability%0A%20%20%20%20FN-%3E%3EFN%3A%20Match%20Data%20with%20SignedHeader%20via%20DataCommitment%0A%20%20%20%20FN-%3E%3ESM%3A%20Apply%20Data%20to%20state%20machine%0A%20%20%20%20FN-%3E%3EFN%3A%20Verify%20locally%20produced%20header%20matches%20received%20Header%0A%20%20%20%20FN-%3E%3EFN%3A%20Mark%20block%20as%20finalized%0A"})]),fallback:s(()=>e[6]||(e[6]=[a(" Loading... ")])),_:1})),e[15]||(e[15]=t("p",null,[a("In a single sequencer mode, before, a full node marks a block finalized, it should verify that both the "),t("code",null,"SignedHeader"),a(" and "),t("code",null,"Data"),a(" associated to it were made available on the DA layer by checking it directly or verifying DA inclusion proofs.")],-1)),e[16]||(e[16]=t("p",null,[a("In based sequencing mode, blocks can be instantly finalized since the "),t("code",null,"Data"),a(" is directly always derived from the DA layer and already exists there. There's no need for a "),t("code",null,"SignedHeader"),a(" to exist on the DA layer.")],-1)),(i(),r(o,null,{default:s(()=>[d(n,{id:"mermaid-81",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20DA%20as%20DA%20Layer%0A%20%20%20%20participant%20FN%20as%20Full%20Node%0A%20%20%20%20participant%20SM%20as%20State%20Machine%0A%0A%20%20%20%20Note%20over%20DA%2CFN%3A%20Based%20Sequencing%20Mode%0A%0A%20%20%20%20DA-%3E%3EFN%3A%20Data%20already%20available%0A%20%20%20%20FN-%3E%3EFN%3A%20Read%20Data%20from%20DA%0A%20%20%20%20FN-%3E%3EFN%3A%20Execute%20transactions%0A%20%20%20%20FN-%3E%3EFN%3A%20Produce%20Header%0A%20%20%20%20FN-%3E%3ESM%3A%20Apply%20state%20changes%0A%20%20%20%20FN-%3E%3EFN%3A%20Finalize%20Block%0A%20%20%20%20Note%20right%20of%20FN%3A%20No%20need%20to%20submit%20SignedHeader%20to%20DA%0A"})]),fallback:s(()=>e[7]||(e[7]=[a(" Loading... ")])),_:1})),e[17]||(e[17]=l('<h2 id="assumptions-and-considerations" tabindex="-1">Assumptions and Considerations <a class="header-anchor" href="#assumptions-and-considerations" aria-label="Permalink to &quot;Assumptions and Considerations&quot;">​</a></h2><ul><li>Considerations include ensuring that headers and data are correctly synchronized and validated to prevent inconsistencies.</li><li>Ensure that all components interacting with headers and data are updated to handle them as separate entities.</li><li>Security measures should be in place to prevent unauthorized access or tampering with headers and data during transmission and storage.</li><li>Performance optimizations may be necessary to handle the increased complexity of managing separate header and data structures, especially in high-throughput environments.</li><li>Testing and validation processes should be updated to account for the new structure and ensure that all components function correctly in both single and decentralized sequencer modes.</li></ul><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h2><p>The implementation of this separation can be found in the Rollkit repository, specifically in the changes made to the <code>manager.go</code> file. The <code>publishBlock</code> method illustrates the creation of separate header and data structures, and the associated logic for handling them independently. See <a href="https://github.com/evstack/ev-node/pull/1789" target="_blank" rel="noreferrer">Rollkit PR #1789</a></p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><a href="https://github.com/evstack/ev-node/pull/1789" target="_blank" rel="noreferrer">Rollkit PR #1789</a></li><li><a href="https://www.alchemy.com/overviews/proposer-builder-separation" target="_blank" rel="noreferrer">Proposer-Builder Separation</a></li></ul>',6))])}const E=h(k,[["render",u]]);export{b as __pageData,E as default};
