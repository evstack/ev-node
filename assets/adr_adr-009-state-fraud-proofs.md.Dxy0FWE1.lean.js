import{_ as n,c as l,ag as i,b as h,w as a,af as r,B as o,o as e,G as p,a as k}from"./chunks/framework.DlgP5dhN.js";const b=JSON.parse('{"title":"ADR 009: State Fraud Proofs","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"ADR 009: State Fraud Proofs | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"adr/adr-009-state-fraud-proofs.md","filePath":"adr/adr-009-state-fraud-proofs.md","lastUpdated":1753438408000}'),d={name:"adr/adr-009-state-fraud-proofs.md"};function c(g,s,u,E,f,y){const t=o("Mermaid");return e(),l("div",null,[s[1]||(s[1]=i('<h1 id="adr-009-state-fraud-proofs" tabindex="-1">ADR 009: State Fraud Proofs <a class="header-anchor" href="#adr-009-state-fraud-proofs" aria-label="Permalink to &quot;ADR 009: State Fraud Proofs&quot;">​</a></h1><h2 id="changelog" tabindex="-1">Changelog <a class="header-anchor" href="#changelog" aria-label="Permalink to &quot;Changelog&quot;">​</a></h2><ul><li>2022-11-03: Initial draft</li><li>2023-02-02: Update design with Deep Subtrees and caveats</li></ul><h2 id="authors" tabindex="-1">Authors <a class="header-anchor" href="#authors" aria-label="Permalink to &quot;Authors&quot;">​</a></h2><p>Manav Aggarwal (@Manav-Aggarwal)</p><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>This ADR introduces a design for state fraud proofs in optimistic cosmos-sdk using Rollkit. It implements parts of Section 4 (Fraud Proofs) of Al-Bassam et al’s paper “Fraud and Data Availability Proofs: Detecting Invalid Blocks in Light Clients”. Some previous notes regarding this topic in the context of cosmos-sdk are described in Matthew Di Ferrante&#39;s <a href="https://github.com/evstack/ev-node/issues/132" target="_blank" rel="noreferrer">notes</a>.</p><p>Rollkit&#39;s design consists of a single sequencer that posts blocks to the DA layer, and multiple (optional) full nodes. Sequencers gossip block headers to full nodes and full nodes fetch posted blocks from the DA layer. Full nodes then execute transactions in these blocks to update their state, and gossip block headers over P2P to Rollkit light nodes. Once State Fraud Proofs are enabled, when a block contains a fraudulent state transition, Rollkit full nodes can detect it by comparing intermediate state roots (ISRs) between transactions, and generate a state fraud proof that can be gossiped over P2P to Rollkit light nodes. These Rollkit light nodes can then use this state fraud proof to verify whether a fraudulent state transition occurred or not by themselves.</p><p>Overall, State Fraud Proofs will enable trust-minimization between full nodes and light node as long as there is at least one honest full node in the system that will generate state fraud proofs.</p><p>Note that Rollkit State Fraud Proofs are still a work in progress and will require new methods on top of ABCI, specifically, <code>GenerateFraudProof</code>, <code>VerifyFraudProof</code>, and <code>GetAppHash</code>.</p><p>List of caveats and required modifications to push State Fraud Proofs towards completion:</p><ul><li>Add ability for light nodes to receive and verify state fraud proofs.</li><li>Add inclusion proofs over transactions so fraud proof verifiers have knowledge over which transaction is being fraud proven.</li><li>Check for badly formatted underlying data before verifying state transition inside the State Machine.</li><li>Limit number of state witnesses permissible in a state fraud proof since state keys accessed by a transaction can be limited by the state machine.</li><li>Write end to end network tests covering different scenarios that can occur in case of state fraud proof submission by a full node.</li><li>Support for multiple sequencers, in which case, fraud proof detection works the same as described above.</li><li>Support more ABCI-compatible State Machines, in addition to the Cosmos SDK state machine.</li></ul>',12)),(e(),h(r,null,{default:a(()=>[p(t,{id:"mermaid-79",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20title%20State%20Fraud%20Proofs%0A%0A%20%20%20%20participant%20User%0A%20%20%20%20participant%20Block%20Producer%0A%20%20%20%20participant%20DA%20Layer%0A%20%20%20%20participant%20Full%20Node%0A%20%20%20%20participant%20Light%20Client%0A%0A%20%20%20%20User-%3E%3EBlock%20Producer%3A%20Send%20Tx%0A%20%20%20%20Block%20Producer-%3E%3EBlock%20Producer%3A%20Generate%20Block%0A%20%20%20%20Block%20Producer-%3E%3EFull%20Node%3A%20Gossip%20Header%0A%20%20%20%20Full%20Node-%3E%3EFull%20Node%3A%20Verify%20Header%0A%20%20%20%20Full%20Node-%3E%3ELight%20Client%3A%20Gossip%20%20Header%0A%0A%20%20%20%20Block%20Producer-%3E%3EFull%20Node%3A%20Gossip%20Block%0A%20%20%20%20Block%20Producer-%3E%3EDA%20Layer%3A%20Publish%20Block%0A%20%20%20%20DA%20Layer-%3E%3EFull%20Node%3A%20Retrieve%20Block%0A%20%20%20%20Full%20Node-%3E%3EFull%20Node%3A%20Verify%20Block%0A%20%20%20%20Full%20Node-%3E%3EFull%20Node%3A%20Generate%20Fraud%20Proof%0A%20%20%20%20Full%20Node-%3E%3ELight%20Client%3A%20Gossip%20Fraud%20Proof%0A%20%20%20%20Light%20Client-%3E%3ELight%20Client%3A%20Verify%20Fraud%20Proof%0A"})]),fallback:a(()=>s[0]||(s[0]=[k(" Loading... ")])),_:1})),s[2]||(s[2]=i(`<h2 id="alternative-approaches" tabindex="-1">Alternative Approaches <a class="header-anchor" href="#alternative-approaches" aria-label="Permalink to &quot;Alternative Approaches&quot;">​</a></h2><p>For light clients to detect invalid blocks and verify it themselves, alternatives include downloading the whole state themselves or using zero-knowledge validity proof systems.</p><h2 id="detailed-design" tabindex="-1">Detailed Design <a class="header-anchor" href="#detailed-design" aria-label="Permalink to &quot;Detailed Design&quot;">​</a></h2><h3 id="detecting-fraudulent-state-transitions" tabindex="-1">Detecting Fraudulent State Transitions <a class="header-anchor" href="#detecting-fraudulent-state-transitions" aria-label="Permalink to &quot;Detecting Fraudulent State Transitions&quot;">​</a></h3><p>Rollkit blocks contain a field called <code>Intermediate State Roots</code> in block data:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Data defines Rollkit block data.</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Txs                    </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Txs</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	IntermediateStateRoots </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IntermediateStateRoots</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>These Intermediate State Roots (ISRs) are initially generated by a Rollkit sequencer during block execution which uses the ABCI interface.</p><p>The following ABCI methods are called during block execution: <code>BeginBlock</code> at the start of a block <code>DeliverTx</code> for each transaction <code>EndBlock</code> at the end of a block</p><p>After each of the above ABCI method calls, we generate an intermediate state root using a new ABCI method we introduce:</p><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">service</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ABCIApplication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    rpc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GetAppHash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestGetAppHash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">returns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ResponseGetAppHash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RequestGetAppHash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResponseGetAppHash</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> app_hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This <code>GetAppHash</code> ABCI method returns an equivalent of <code>CommitID</code> hash in the ABCI method <code>Commit</code> and thus provides a way to extract ISRs from an app without doing any disk write operations.</p><p>Full nodes use these ISRs to detect fraudulent state transitions. A full node must also execute all state transitions (<code>BeginBlock</code>, <code>DeliverTx</code>, and <code>EndBlock</code> calls) and compute its own Intermediate State Roots (ISRs). After each state transition, a full node compares the corresponding ISR with the ISR given by the Sequencer. If it finds a mismatch between its own computed ISR and one given by the Sequencer, a fraudulent transition is detected and it moves on to generate a State Fraud Proof.</p><h3 id="generating-state-fraud-proofs" tabindex="-1">Generating State Fraud Proofs <a class="header-anchor" href="#generating-state-fraud-proofs" aria-label="Permalink to &quot;Generating State Fraud Proofs&quot;">​</a></h3><p>Note: Starting from this section, this ADR refers to State Fraud Proofs simply as Fraud Proofs.</p><p>We introduce the following ABCI method to enable Fraud Proof Generation in the Cosmos SDK:</p><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">service</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ABCIApplication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    rpc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> GenerateFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestGenerateFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">returns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ResponseGenerateFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>With this new ABCI method, a Rollkit Full Node can send a request to a Cosmos SDK app to generate a Fraud Proof. In this request, it includes a list of all the state transitions from the start of the block upto the fraudulent state transition. The last non-nil state transition in this list corresponds to the fraudulent state transition.</p><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RequestGenerateFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // All state transitions upto and including the fraudulent state transition</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  RequestBeginBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> begin_block_request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">(gogoproto.nullable)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  repeated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> RequestDeliverTx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deliver_tx_requests </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  RequestEndBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> end_block_request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The <code>GenerateFraudProof</code> method in the Cosmos SDK app receives this list of state transitions and takes the following steps to generate a fraud proof:</p><ul><li>Revert local state to the last committed state</li><li>Execute all the non-fraudulent state transitions</li><li>Enable tracing and execute the fraudulent state transition. Tracing stores logs of what state, specifically key/value pairs, is accessed during this fraudulent state transition and generates corresponding merkle inclusion proofs of each action (read, write, delete) log. These logs correspond to state witnesses needed to re-execute this state transition.</li><li>Revert local state back to the last committed state</li><li>Execute all the non-fraudulent state transitions again</li><li>Construct a State Fraud Proof with the state witnesses generated earlier which looks like this:</li></ul><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Represents a single-round state fraudProof</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> FraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // The block height during which the fraudulent state transition occurred</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  uint64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> block_height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Intermediate State Root right before the fraudulent state transition</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pre_state_app_hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Intermediate State Root right after the fraudulent state transition</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expected_valid_app_hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Map from an app module name to a State Witness</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">StateWitness</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; state_witness </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Fraudulent state transition has to be one of these</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Only one of these three can be non-nil</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  RequestBeginBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fraudulent_begin_block </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  RequestDeliverTx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fraudulent_deliver_tx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  RequestEndBlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fraudulent_end_block </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// State witness with a list of all witness data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> StateWitness</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // store level merkle inclusion proof</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  tendermint.crypto.ProofOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proof </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // merkle root hash of the substore</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> root_hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // List of witness data</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  repeated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WitnessData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> witness_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Witness data containing operation, a key/value pair, and Merkle</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// inclusion proofs needed for corresponding operation for key/value pair</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WitnessData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> operation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // only set for &quot;write&quot; operation</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  repeated</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> tendermint.crypto.ProofOp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proofs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   WRITE     </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">(gogoproto.enumvalue_customname)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;write&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   READ      </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">(gogoproto.enumvalue_customname)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;read&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   DELETE    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">(gogoproto.enumvalue_customname)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;delete&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Finally, return this generated state fraud proof back to the Rollkit Full Node:</p><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResponseGenerateFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  FraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fraud_proof </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Note that currently the only underlying store supported by Cosmos SDK is the Merkle IAVL+ tree. As part of generating state witnesses, we added preliminary support for Deep Subtrees to this library <a href="https://github.com/rollkit/iavl/tree/deepsubtrees_0.19.x" target="_blank" rel="noreferrer">here</a>. It enables import and export of partial state and adds tracing to IAVL trees. Note that documentation and exploring optimizations of Deep Subtrees is a work in progress.</p><h3 id="gossiping-fraud-proofs" tabindex="-1">Gossiping Fraud Proofs <a class="header-anchor" href="#gossiping-fraud-proofs" aria-label="Permalink to &quot;Gossiping Fraud Proofs&quot;">​</a></h3><p>After a Rollkit Full Node generates a Fraud Proof, it gossips the Fraud Proof over P2P to Rollkit light clients.</p><h3 id="verifying-fraud-proofs" tabindex="-1">Verifying Fraud Proofs <a class="header-anchor" href="#verifying-fraud-proofs" aria-label="Permalink to &quot;Verifying Fraud Proofs&quot;">​</a></h3><p>Rollkit light clients should be able to use these gossiped state fraud proofs to verify whether a fraudulent state transition occurred or not by themselves.</p><p>There are four stages of verification that must occur for a Fraud Proof. The first three stages take place in Rollkit and verify that the fraud proof itself was generated correctly. The fourth stage takes place in a Cosmos SDK app to actually execute the fraudulent state transition embedded in the fraud proof.</p><h4 id="stage-one" tabindex="-1"><strong>Stage One</strong> <a class="header-anchor" href="#stage-one" aria-label="Permalink to &quot;**Stage One**&quot;">​</a></h4><p>Verify that both the <code>appHash</code> (ISR) and the fraudulent state transition in the <code>FraudProof</code> exist as part of a block published on the DA layer within a specified fraud proof window. This involves verifying that the blob corresponding to the block is posted on the DA layer via a Blob Inclusion Proof and verifying the share(s) containing the fraudulent state transition and <code>appHash</code> were part of that blob via Share Inclusion Proof(s).</p><h4 id="stage-two" tabindex="-1"><strong>Stage Two</strong> <a class="header-anchor" href="#stage-two" aria-label="Permalink to &quot;**Stage Two**&quot;">​</a></h4><p>Go through the <code>state_witness</code> list in the <code>FraudProof</code> and verify that all the store level merkle inclusion proofs are valid: the corresponding <code>root_hash</code> was included in a merkle tree with root <code>appHash</code>.</p><h4 id="stage-three" tabindex="-1"><strong>Stage Three</strong> <a class="header-anchor" href="#stage-three" aria-label="Permalink to &quot;**Stage Three**&quot;">​</a></h4><p>Go through the <code>WitnessData</code> in each <code>StateWitness</code> and verify that the first substore level merkle inclusion proof is valid: the corresponding <code>key</code> was included in a merkle tree with root <code>root_hash</code>. Note that we can only verify the first witness in this witnessData with current root hash. Other proofs are verified in the IAVL tree when re-executing operations in the underlying IAVL Deep Subtree.</p><h4 id="stage-four" tabindex="-1"><strong>Stage Four</strong> <a class="header-anchor" href="#stage-four" aria-label="Permalink to &quot;**Stage Four**&quot;">​</a></h4><p>Spin up a new Cosmos SDK app and initialize its store with Deep Subtrees constructed using witness data in the <code>FraudProof</code>. After this initialization, the app hash representing the state of the app should match the <code>appHash</code> inside the <code>FraudProof</code>. This store should now contain all the key/value pairs and underlying tree structure necessary to execute the fraudulent state transition contained in the <code>FraudProof</code>.</p><p>We introduce the following ABCI method to enable Fraud Proof Verification in the Cosmos SDK:</p><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">service</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ABCIApplication</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    rpc</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VerifyFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RequestVerifyFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">returns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ResponseVerifyFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>With this new ABCI method, a Rollkit light client can send a request to a newly initialized Cosmos SDK app to verify whether executing a state transition on the app would lead to a particular app hash. In this request, it includes the fraudulent state transition and an expected app hash to match against.</p><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RequestVerifyFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  FraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fraud_proof </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Note: to be removed. Moved inside state fraud proof</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bytes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expected_valid_app_hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The <code>VerifyFraudProof</code> method in the Cosmos SDK app receives this fraudulent state transition and expected app hash, and takes the following steps to complete this verification step:</p><ul><li>Execute the provided fraudulent state transition</li><li>Get the app hash and compare it against the expected app hash</li><li>Return a boolean representing whether the two app hashes above match or not.</li></ul><div class="language-protobuf vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">protobuf</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">message</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResponseVerifyFraudProof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> success </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>If a fraud proof is successfully verified, the Rollkit light client can halt and wait for an off-chain social recovery process. Otherwise, it ignores the Fraud Proof and proceeds as usual.</p><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><p>Proposed</p><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="positive" tabindex="-1">Positive <a class="header-anchor" href="#positive" aria-label="Permalink to &quot;Positive&quot;">​</a></h3><ul><li>Enables trust-minimization between Rollkit Full nodes and Light clients.</li><li>Introduces an honest minority assumption for Rollkit full nodes.</li></ul><h3 id="negative" tabindex="-1">Negative <a class="header-anchor" href="#negative" aria-label="Permalink to &quot;Negative&quot;">​</a></h3><ul><li>Breaks ABCI compatibility and requires maintaining an ABCI version specific to Rollkit.</li></ul><h2 id="working-branches" tabindex="-1">Working Branches <a class="header-anchor" href="#working-branches" aria-label="Permalink to &quot;Working Branches&quot;">​</a></h2><p>A prototype implementation of the above design is available in the following working branches:</p><ul><li><a href="https://github.com/evstack/ev-node/releases/tag/v0.6.0" target="_blank" rel="noreferrer">Rollkit</a>: Contains fraud proof detection and gossiping logic. As fraud proofs are currently a work in progress, this logic can be toggled using a flag <code>--rollkit.experimental_insecure_fraud_proofs</code>. By default, this flag is set to <code>false</code>.</li><li><a href="https://github.com/rollkit/cosmos-sdk-old/tree/manav/fraudproof_iavl_prototype" target="_blank" rel="noreferrer">Cosmos-SDK</a>: Implements the new ABCI methods described.</li><li><a href="https://github.com/rollkit/tendermint/tree/abci_fraud_proofs" target="_blank" rel="noreferrer">Tendermint</a>: Contains modifications to the ABCI interface described.</li><li><a href="https://github.com/rollkit/iavl/tree/deepsubtrees_0.19.x" target="_blank" rel="noreferrer">IAVL</a>: Adds support for Deep Subtrees and tracing.</li></ul><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><blockquote><p>Are there any relevant PR comments, issues that led up to this, or articles referenced for why we made the given design choice? If so link them here!</p></blockquote><ul><li><a href="https://github.com/evstack/ev-node/issues/132" target="_blank" rel="noreferrer">https://github.com/evstack/ev-node/issues/132</a></li><li><a href="https://github.com/evstack/ev-node/issues/514" target="_blank" rel="noreferrer">https://github.com/evstack/ev-node/issues/514</a></li></ul>`,58))])}const m=n(d,[["render",c]]);export{b as __pageData,m as default};
