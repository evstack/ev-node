import{_ as t,c as o,ag as n,b as r,w as i,af as l,B as c,o as s,G as d,a as u}from"./chunks/framework.DlgP5dhN.js";const k=JSON.parse('{"title":"Single Sequencer","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Single Sequencer | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"learn/sequencing/single.md","filePath":"learn/sequencing/single.md","lastUpdated":1764781917000}'),h={name:"learn/sequencing/single.md"};function p(g,e,m,b,f,q){const a=c("Mermaid");return s(),o("div",null,[e[1]||(e[1]=n('<h1 id="single-sequencer" tabindex="-1">Single Sequencer <a class="header-anchor" href="#single-sequencer" aria-label="Permalink to &quot;Single Sequencer&quot;">​</a></h1><p>A single sequencer is the simplest sequencing architecture for an Evolve-based chain. In this model, one node (the sequencer) is responsible for ordering transactions, producing blocks, and submitting data to the data availability (DA) layer.</p><h2 id="how-the-single-sequencer-model-works" tabindex="-1">How the Single Sequencer Model Works <a class="header-anchor" href="#how-the-single-sequencer-model-works" aria-label="Permalink to &quot;How the Single Sequencer Model Works&quot;">​</a></h2><ol><li><p><strong>Transaction Submission:</strong></p><ul><li>Users submit transactions to the execution environment via RPC or other interfaces.</li></ul></li><li><p><strong>Transaction Collection and Ordering:</strong></p><ul><li>The execution environment collects incoming transactions.</li><li>The sequencer requests a batch of transactions from the execution environment to be included in the next block.</li></ul></li><li><p><strong>Block Production:</strong></p><ul><li><strong>Without lazy mode:</strong> the sequencer produces new blocks at fixed intervals.</li><li><strong>With lazy mode:</strong> the sequencer produces a block once either <ul><li>enough transactions are collected</li><li>the lazy-mode block interval elapses More info in the <a href="./../config#lazy-mode-lazy-aggregator">lazy mode configuration guide</a>.</li></ul></li><li>Each block contains a batch of ordered transactions and metadata.</li></ul></li><li><p><strong>Data Availability Posting:</strong></p><ul><li>The sequencer posts the block data to the configured DA layer (e.g., Celestia).</li><li>This ensures that anyone can access the data needed to reconstruct the chain state.</li></ul></li><li><p><strong>State Update:</strong></p><ul><li>The sequencer updates the chain state based on the new block and makes the updated state available to light clients and full nodes.</li></ul></li></ol><h2 id="transaction-flow-diagram" tabindex="-1">Transaction Flow Diagram <a class="header-anchor" href="#transaction-flow-diagram" aria-label="Permalink to &quot;Transaction Flow Diagram&quot;">​</a></h2>',5)),(s(),r(l,null,{default:i(()=>[d(a,{id:"mermaid-106",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20User%0A%20%20%20%20participant%20ExecutionEnv%20as%20Execution%20Environment%0A%20%20%20%20participant%20Sequencer%0A%20%20%20%20participant%20DA%20as%20Data%20Availability%20Layer%0A%0A%20%20%20%20User-%3E%3EExecutionEnv%3A%20Submit%20transaction%0A%20%20%20%20Sequencer-%3E%3EExecutionEnv%3A%20Request%20batch%20for%20block%0A%20%20%20%20ExecutionEnv-%3E%3ESequencer%3A%20Provide%20batch%20of%20transactions%0A%20%20%20%20Sequencer-%3E%3EDA%3A%20Post%20block%20data%0A%20%20%20%20Sequencer-%3E%3EExecutionEnv%3A%20Update%20state%0A%20%20%20%20ExecutionEnv-%3E%3EUser%3A%20State%2Fquery%20response%0A"})]),fallback:i(()=>e[0]||(e[0]=[u(" Loading... ")])),_:1})),e[2]||(e[2]=n(`<h2 id="forced-inclusion" tabindex="-1">Forced Inclusion <a class="header-anchor" href="#forced-inclusion" aria-label="Permalink to &quot;Forced Inclusion&quot;">​</a></h2><p>While the single sequencer controls transaction ordering, the system provides a censorship-resistance mechanism called <strong>forced inclusion</strong>. This ensures users can always include their transactions even if the sequencer refuses to process them.</p><h3 id="how-forced-inclusion-works" tabindex="-1">How Forced Inclusion Works <a class="header-anchor" href="#how-forced-inclusion-works" aria-label="Permalink to &quot;How Forced Inclusion Works&quot;">​</a></h3><ol><li><p><strong>Direct DA Submission:</strong></p><ul><li>Users can submit transactions directly to the DA layer&#39;s forced inclusion namespace</li><li>These transactions bypass the sequencer entirely</li></ul></li><li><p><strong>Epoch-Based Retrieval:</strong></p><ul><li>The sequencer retrieves forced inclusion transactions from the DA layer at epoch boundaries</li><li>Epochs are defined by <code>DAEpochForcedInclusion</code> in the genesis configuration</li></ul></li><li><p><strong>Mandatory Inclusion:</strong></p><ul><li>The sequencer MUST include all forced inclusion transactions from an epoch before the epoch ends</li><li>Full nodes verify that forced inclusion transactions are properly included</li></ul></li><li><p><strong>Smoothing:</strong></p><ul><li>If forced inclusion transactions exceed block size limits (<code>MaxBytes</code>), they can be spread across multiple blocks within the same epoch</li><li>All transactions must be included before moving to the next epoch</li></ul></li></ol><h3 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h3><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Epoch [100, 109] (epoch size = 10):</span></span>
<span class="line"><span>  - User submits tx directly to DA at height 102</span></span>
<span class="line"><span>  - Sequencer retrieves forced txs at epoch start (height 100)</span></span>
<span class="line"><span>  - Sequencer includes forced tx in blocks before height 110</span></span></code></pre></div><p>See <a href="./based">Based Sequencing</a> for a fully decentralized alternative that relies entirely on forced inclusion.</p><h2 id="detecting-malicious-sequencer-behavior" tabindex="-1">Detecting Malicious Sequencer Behavior <a class="header-anchor" href="#detecting-malicious-sequencer-behavior" aria-label="Permalink to &quot;Detecting Malicious Sequencer Behavior&quot;">​</a></h2><p>Full nodes continuously monitor the sequencer to ensure it follows consensus rules, particularly around forced inclusion:</p><h3 id="censorship-detection" tabindex="-1">Censorship Detection <a class="header-anchor" href="#censorship-detection" aria-label="Permalink to &quot;Censorship Detection&quot;">​</a></h3><p>If a sequencer fails to include forced inclusion transactions past their epoch boundary, full nodes will:</p><ol><li><strong>Detect the violation</strong> - missing transactions from past epochs</li><li><strong>Reject invalid blocks</strong> - do not build on top of censoring blocks</li><li><strong>Log the violation</strong> with transaction hashes and epoch details</li><li><strong>Halt consensus</strong> - the chain cannot progress with a malicious sequencer</li></ol><h3 id="recovery-from-malicious-sequencer" tabindex="-1">Recovery from Malicious Sequencer <a class="header-anchor" href="#recovery-from-malicious-sequencer" aria-label="Permalink to &quot;Recovery from Malicious Sequencer&quot;">​</a></h3><p>When a malicious sequencer is detected (censoring forced inclusion transactions):</p><p><strong>All nodes must restart the chain in based sequencing mode:</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Restart with based sequencing enabled</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./evnode</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --node.aggregator</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --node.based_sequencer</span></span></code></pre></div><p><strong>In based sequencing mode:</strong></p><ul><li>No single sequencer controls transaction ordering</li><li>Every full node derives blocks independently from the DA layer</li><li>Forced inclusion becomes the primary (and only) transaction submission method</li><li>Censorship becomes impossible as ordering comes from the DA layer</li></ul><p><strong>Important considerations:</strong></p><ul><li>All full nodes should coordinate the switch to based mode</li><li>The chain continues from the last valid state</li><li>Users submit transactions directly to the DA layer going forward</li><li>This is a one-way transition - moving back to single sequencer requires social consensus</li></ul><p>See <a href="./based">Based Sequencing documentation</a> for details on operating in this mode.</p><h2 id="advantages" tabindex="-1">Advantages <a class="header-anchor" href="#advantages" aria-label="Permalink to &quot;Advantages&quot;">​</a></h2><ul><li><strong>Simplicity:</strong> Easy to set up and operate, making it ideal for development, testing, and small-scale deployments compared to other more complex sequencers.</li><li><strong>Low Latency:</strong> Fast block production and transaction inclusion, since there is no consensus overhead among multiple sequencers.</li><li><strong>Independence from DA block time:</strong> The sequencer can produce blocks on its own schedule, without being tied to the block time of the DA layer, enabling more flexible transaction processing than DA-timed sequencers.</li><li><strong>Forced inclusion fallback:</strong> Users can always submit transactions via the DA layer if the sequencer is unresponsive or censoring.</li></ul><h2 id="disadvantages" tabindex="-1">Disadvantages <a class="header-anchor" href="#disadvantages" aria-label="Permalink to &quot;Disadvantages&quot;">​</a></h2><ul><li><strong>Single point of failure:</strong> If the sequencer goes offline, block production stops (though the chain can transition to based mode).</li><li><strong>Trust requirement:</strong> Users must trust the sequencer to include their transactions in a timely manner (mitigated by forced inclusion).</li><li><strong>Censorship risk:</strong> A malicious sequencer can temporarily censor transactions until forced inclusion activates or the chain transitions to based mode.</li></ul>`,25))])}const y=t(h,[["render",p]]);export{k as __pageData,y as default};
