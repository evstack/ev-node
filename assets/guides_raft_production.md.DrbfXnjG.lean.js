import{_ as t,c as o,ag as a,o as i}from"./chunks/framework.DlgP5dhN.js";const g=JSON.parse('{"title":"Raft Implementation & Production Configuration","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Raft Implementation & Production Configuration | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"guides/raft_production.md","filePath":"guides/raft_production.md","lastUpdated":1769586110000}'),n={name:"guides/raft_production.md"};function r(s,e,d,l,c,h){return i(),o("div",null,e[0]||(e[0]=[a(`<h1 id="raft-implementation-production-configuration" tabindex="-1">Raft Implementation &amp; Production Configuration <a class="header-anchor" href="#raft-implementation-production-configuration" aria-label="Permalink to &quot;Raft Implementation &amp; Production Configuration&quot;">​</a></h1><p>This guide details the Raft consensus implementation in <code>ev-node</code>, used for High Availability (HA) of the Sequencer/Aggregator. It is targeted at experienced DevOps and developers configuring production environments.</p><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h2><p><code>ev-node</code> uses the <a href="https://github.com/hashicorp/raft" target="_blank" rel="noreferrer">HashiCorp Raft</a> implementation to manage leader election and state replication when running in <strong>Aggregator Mode</strong>.</p><ul><li><strong>Role</strong>: Ensures only one active Aggregator (Leader) produces blocks at a time.</li><li><strong>Failover</strong>: Automatically elects a new leader if the current leader fails.</li><li><strong>Safety</strong>: Synchronizes the block production state to prevent double-signing or fork divergence.</li></ul><h3 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">​</a></h3><ul><li><strong>Transport</strong>: TCP-based transport for inter-node communication.</li><li><strong>Storage</strong>: <a href="https://github.com/etcd-io/bbolt" target="_blank" rel="noreferrer">BoltDB</a> is used for both the Raft Log (<code>raft-log.db</code>) and Stable Store (<code>raft-stable.db</code>). Snapshots are stored as files.</li><li><strong>FSM (Finite State Machine)</strong>: The State Machine applies <code>RaftBlockState</code> (Protobuf) containing the latest block height, hash, and timestamp.</li><li><strong>Safety Checks</strong>: <ul><li><strong>Startup</strong>: Nodes check for divergence between local block store and Raft state.</li><li><strong>Leadership Transfer</strong>: Before becoming leader, a node waits for its FSM to catch up (<code>waitForMsgsLanded</code>) to prevent proposing blocks from a stale state.</li><li><strong>Shutdown</strong>: The leader attempts to transfer leadership gracefully before shutting down to minimize downtime.</li></ul></li></ul><h2 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h2><p>Raft is configured via CLI flags or the <code>config.toml</code> file under the <code>[raft]</code> (or <code>[rollkit.raft]</code>) section.</p><h3 id="essential-flags" tabindex="-1">Essential Flags <a class="header-anchor" href="#essential-flags" aria-label="Permalink to &quot;Essential Flags&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Flag</th><th>Config Key</th><th>Description</th><th>Production Value</th></tr></thead><tbody><tr><td><code>--evnode.raft.enable</code></td><td><code>raft.enable</code></td><td>Enable Raft consensus.</td><td><code>true</code></td></tr><tr><td><code>--evnode.raft.node_id</code></td><td><code>raft.node_id</code></td><td><strong>Unique</strong> identifier for the node.</td><td>e.g., <code>node-01</code></td></tr><tr><td><code>--evnode.raft.raft_addr</code></td><td><code>raft.raft_addr</code></td><td>TCP address for Raft transport.</td><td><code>0.0.0.0:5001</code> (Bind to private IP)</td></tr><tr><td><code>--evnode.raft.raft_dir</code></td><td><code>raft.raft_dir</code></td><td>Directory for Raft data.</td><td><code>/data/raft</code> (Must be persistent)</td></tr><tr><td><code>--evnode.raft.peers</code></td><td><code>raft.peers</code></td><td>Comma-separated list of peer addresses in format <code>nodeID@host:port</code>.</td><td><code>node-1@10.0.0.1:5001,node-2@10.0.0.2:5001,node-3@10.0.0.3:5001</code></td></tr><tr><td><code>--evnode.raft.bootstrap</code></td><td><code>raft.bootstrap</code></td><td>Bootstrap the cluster. <strong>Required</strong> for initial setup.</td><td><code>true</code> (See Limitations)</td></tr></tbody></table><h3 id="timeout-tuning" tabindex="-1">Timeout Tuning <a class="header-anchor" href="#timeout-tuning" aria-label="Permalink to &quot;Timeout Tuning&quot;">​</a></h3><p>Raft timeouts should be tuned relative to your <strong>Block Time</strong> (<code>--evnode.node.block_time</code>) to utilize the fast failover capabilities without causing instability.</p><table tabindex="0"><thead><tr><th>Flag</th><th>Default</th><th>Recommended Tuning</th></tr></thead><tbody><tr><td><code>--evnode.raft.heartbeat_timeout</code></td><td><code>1s</code></td><td><strong>10-30% of Leader Lease</strong>. For sub-second block times, lower to <code>50ms-100ms</code>.</td></tr><tr><td><code>--evnode.raft.leader_lease_timeout</code></td><td><code>500ms</code></td><td><strong>Must be &lt; Election Timeout</strong>. Use <code>500ms</code> for 1s block times. For slower chains (e.g., 10s blocks), increase to <code>1s-2s</code> to tolerate network jitter.</td></tr><tr><td><code>--evnode.raft.send_timeout</code></td><td><code>1s</code></td><td>Should be <code>&gt; 2x RTT</code>.</td></tr></tbody></table><p><strong>Relation to Block Time</strong>: Ideally, a failover should complete within <code>2 * BlockTime</code> to minimize user impact.</p><ul><li><strong>Fast Chain (BlockTime &lt; 1s)</strong>: Tighten timeouts. Heartbeat <code>50ms</code>, Lease <code>250ms</code>.</li><li><strong>Standard Chain (BlockTime = 1s)</strong>: Heartbeat <code>100ms</code>, Lease <code>500ms</code>.</li><li><strong>Slow Chain (BlockTime &gt; 5s)</strong>: Defaults are usually sufficient (<code>1s</code> heartbeat).</li></ul><blockquote><p><strong>Warning</strong>: Setting timeouts too low (&lt; RTT + Jitter) will cause leadership flapping and halted block production.</p></blockquote><h2 id="production-deployment-principles" tabindex="-1">Production Deployment Principles <a class="header-anchor" href="#production-deployment-principles" aria-label="Permalink to &quot;Production Deployment Principles&quot;">​</a></h2><h3 id="_1-static-peering-bootstrap" tabindex="-1">1. Static Peering &amp; Bootstrap <a class="header-anchor" href="#_1-static-peering-bootstrap" aria-label="Permalink to &quot;1. Static Peering &amp; Bootstrap&quot;">​</a></h3><p>Current implementation requires <strong>Bootstrap Mode</strong> (<code>--evnode.raft.bootstrap=true</code>) for all nodes participating in the cluster initialization.</p><ul><li><strong>All nodes</strong> should list the full set of peers in <code>--evnode.raft.peers</code>.</li><li>The <code>peers</code> list format is strict: <code>NodeID@Host:Port</code>.</li><li><strong>Limitation</strong>: Dynamic addition of peers (Run-time Membership Changes) via RPC/CLI is not currently exposed. The cluster membership is static based on the initial bootstrap configuration.</li></ul><h3 id="_2-infrastructure-requirements" tabindex="-1">2. Infrastructure Requirements <a class="header-anchor" href="#_2-infrastructure-requirements" aria-label="Permalink to &quot;2. Infrastructure Requirements&quot;">​</a></h3><ul><li><strong>Encrypted Network (CRITICAL)</strong>: Raft traffic is <strong>unencrypted</strong> (plain TCP). You <strong>MUST</strong> run the cluster inside a private network, VPN, or encrypted mesh (e.g., WireGuard, Tailscale). <strong>Never expose Raft ports to the public internet</strong>; doing so allows attackers to hijack the cluster consensus.</li><li><strong>Cluster Size</strong>: Run an <strong>odd number</strong> of nodes (3 or 5) to tolerate failures (3 nodes tolerate 1 failure; 5 nodes tolerate 2).</li><li><strong>Storage</strong>: The <code>--evnode.raft.raft_dir</code> <strong>MUST</strong> be mounted on persistent storage. Loss of this directory will cause the node to lose its identity and commit history, effectively removing it from the cluster.</li><li><strong>Network</strong>: Raft requires low-latency, reliable connectivity. Ensure firewall rules allow TCP traffic on <code>raft_addr</code>.</li></ul><h3 id="_3-p2p-interaction-catch-up" tabindex="-1">3. P2P Interaction &amp; Catch-Up <a class="header-anchor" href="#_3-p2p-interaction-catch-up" aria-label="Permalink to &quot;3. P2P Interaction &amp; Catch-Up&quot;">​</a></h3><p>Raft and P2P work in parallel to ensure reliability:</p><ul><li><strong>Hot Replication (Raft)</strong>: New blocks produced by the leader are replicated via the Raft transport (Header + Data) to all followers. This ensures low-latency propagation of the chain tip.</li><li><strong>Catch-Up (P2P)</strong>: If a node falls behind (e.g., disconnected for longer than the Raft log retention), it will receive a <strong>Raft Snapshot</strong> to update its consensus state to the latest head. However, the <em>historical blocks</em> between its local state and the new head are fetched via the <strong>P2P Network</strong> (or DA). <ul><li><strong>Implication</strong>: You must ensure P2P connectivity (<code>--p2p.listen_address</code> and <code>--p2p.peers</code>) is configured even for Raft nodes, to allow them to backfill missing data from peers.</li></ul></li></ul><h3 id="_4-lifecycle-management" tabindex="-1">4. Lifecycle Management <a class="header-anchor" href="#_4-lifecycle-management" aria-label="Permalink to &quot;4. Lifecycle Management&quot;">​</a></h3><ul><li><strong>Rolling Restarts</strong>: You can restart nodes one by one. The <code>ev-node</code> implementation handles graceful shutdown (leadership transfer) to minimize impact.</li><li><strong>State Divergence</strong>: If a node falls too far behind or its local store conflicts with Raft (e.g., due to catastrophic disk failure), it may panic on startup to protect safety. In such cases, a manual extensive recovery (wiping state and re-syncing) may be required.</li></ul><h3 id="_4-monitoring" tabindex="-1">4. Monitoring <a class="header-anchor" href="#_4-monitoring" aria-label="Permalink to &quot;4. Monitoring&quot;">​</a></h3><p>Monitor the following metrics (propagated via Prometheus if enabled):</p><ul><li><strong>Leadership Changes</strong>: Frequent changes indicate network instability or overloaded nodes.</li><li><strong>Applied Index vs Commit Index</strong>: A growing lag indicates the FSM cannot keep up.</li></ul><h2 id="example-command" tabindex="-1">Example Command <a class="header-anchor" href="#example-command" aria-label="Permalink to &quot;Example Command&quot;">​</a></h2><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./ev-node</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> start</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --node.aggregator</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --raft.enable</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --raft.node_id=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node-1&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --raft.raft_addr=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0.0.0.0:5001&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --raft.raft_dir=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/var/lib/ev-node/raft&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --raft.bootstrap=true</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --raft.peers=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;node-1@10.0.1.1:5001,node-2@10.0.1.2:5001,node-3@10.0.1.3:5001&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  --p2p.listen_address=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/ip4/0.0.0.0/tcp/26656&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  ...other</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> flags</span></span></code></pre></div>`,33)]))}const u=t(n,[["render",r]]);export{g as __pageData,u as default};
