import{_ as d,c,ag as a,b as n,w as t,af as s,B as h,o as i,G as r,a as l}from"./chunks/framework.DlgP5dhN.js";const w=JSON.parse('{"title":"022 Validator Network","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"022 Validator Network | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"adr/adr-022-validator-network.md","filePath":"adr/adr-022-validator-network.md","lastUpdated":1755768201000}'),u={name:"adr/adr-022-validator-network.md"};function p(m,e,g,f,b,v){const o=h("Mermaid");return i(),c("div",null,[e[2]||(e[2]=a('<h1 id="_022-validator-network" tabindex="-1">022 Validator Network <a class="header-anchor" href="#_022-validator-network" aria-label="Permalink to &quot;022 Validator Network&quot;">​</a></h1><p>Date: 2025-05-25 Status: Draft</p><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>When a single sequencer is used there is a limited design space for the token and a limited set of security guarantees. The validator network offers an alternative to using a full consensus protocol, but offers security guarantees with more than one participant verifying the execution and ordering.</p><p>The validator network acts as an extra security layer and soft confirmation enabling the rollup to move faster than the underlying DA layer with added security. Secondly a validator network introduces the opportunity to do more with the token of the chain.</p><p>The original design and implementation was centered around IBC and adding an extra layer of security for counter party chains, so that the user is not solely trusting the sequencer to act correctly</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><p>Evolve will introduce a validator network in which there will be a set of validators verifying execution and construction.</p><p>Validators sign <strong>one Attestation per epoch</strong> that covers every block proposed inside that epoch. The Attestation must be broadcast as a transaction within a configurable <strong>SubmissionWindow</strong> (measured in blocks and always ≤ <code>EpochLength</code>). Missing the window does <strong>not</strong> incur slashing but the validator forfeits rewards for that epoch. If a validator fails to submit an Attestation for <strong>NonParticipationEpochs</strong> consecutive epochs it is automatically removed from the active validator set (stake remains bonded unless separate evidence triggers slashing).</p><p>The design is centered around the proposer producing blocks as fast as possible and asking for signatures <strong>after the fact, once per epoch</strong>. This maximises throughput while still obtaining soft-finality from a multi-party validator set.</p><h3 id="high-level-workflow" tabindex="-1">High-level workflow <a class="header-anchor" href="#high-level-workflow" aria-label="Permalink to &quot;High-level workflow&quot;">​</a></h3><ol><li>Block broadcast — For every height h the sequencer broadcasts the canonical BlockBundle(h) (header, transactions, state root) to all active attesters over gRPC/WebSocket.</li><li>Local verification — Each attester independently: • validates every block header in the epoch and the resulting state transition; • (optionally) re-executes the blocks using a connected full node; • after processing the last block of the epoch, what is signs is up to the execution environment.</li><li>Attestation submission — The attester sends the epoch signature as a transaction <strong>within SubmissionWindow</strong>.</li><li>Aggregation &amp; quorum — The attester module / contract collects epoch signatures until ≥ ⅔ of current bonded voting power have signed, providing a soft confirmation of the whole epoch. <ul><li>If quorum is not met by the epoch boundary, the network pauses new proposals until quorum is reached or <strong>EmergencyMode</strong> governance override is enabled.</li></ul></li><li>Final block commit — After the block is included in the DA layer it will be considered to have a hard confirmation.</li></ol><h3 id="signing-schemes" tabindex="-1">Signing schemes <a class="header-anchor" href="#signing-schemes" aria-label="Permalink to &quot;Signing schemes&quot;">​</a></h3><p>Different signature schemes can be used in conjunction with the validator network. To start we will support ED25519 and later one we plan on adding other signature schemes based on how user demand requires.</p><p>Some potential future additions could be BLS12-381 aggregate and/or a BLS threshold signature.</p><h3 id="validator-set-staking-integration" tabindex="-1">Validator set &amp; staking integration <a class="header-anchor" href="#validator-set-staking-integration" aria-label="Permalink to &quot;Validator set &amp; staking integration&quot;">​</a></h3><p>The attester layer can plug into different validator‑set providers. Below we outline the existing Cosmos‑SDK flow and an alternative Reth / EVM flow patterned after UniChain’s staking design. Both share the same quorum rule (≥ ⅔ voting power) and slashing philosophy.</p><h4 id="cosmos‐sdk" tabindex="-1">Cosmos‑SDK <a class="header-anchor" href="#cosmos‐sdk" aria-label="Permalink to &quot;Cosmos‑SDK&quot;">​</a></h4><p>Introduce a dedicated x/network module that completely owns the CommitHash and ValidatorHash that appear in every block‑header. Evolve remains untouched; the logic lives entirely in the ABCI application.</p><p>Hashes produced in‑app During EndBlock, x/network gathers the attestation bitmap for height h, computes and returns them in ResponseEndBlock.</p><p>When a relayer queries /block or /header, the application serves the canonical valset hash and commit hash from its KV‑store, ensuring external clients see the attested header even though Evolve itself never verified the signatures.</p><p>Validatorset updates from the staking module (x/staking) remains the single source of truth for bonded power. Every block it emits a ValidatorSetUpdate event. x/network subscribes and mirrors the active validator bitmap. On a set‑change (say at height 100) the EndBlock hook updates x/network&#39;s bitmap before computing the hashes for the next height.</p><h5 id="flow" tabindex="-1">Flow <a class="header-anchor" href="#flow" aria-label="Permalink to &quot;Flow&quot;">​</a></h5>',23)),(i(),n(s,null,{default:t(()=>[r(o,{id:"mermaid-100",class:"mermaid",graph:"sequenceDiagram%0A%20%20participant%20Val%20as%20Validator%0A%20%20participant%20App%20as%20x%2Fnetwork%0A%20%20participant%20R%20as%20Evolve%0A%20%20Val-%3E%3EApp%3A%20MsgAttest%7Bh%2C%20sig%7D%0A%20%20loop%20within%20epoch%0A%20%20%20%20%20%20App-%3E%3EApp%3A%20store%20sig%2C%20update%20bitmap%0A%20%20%20%20%20%20App-%3E%3EApp%3AEndBlock%7BValidatorHash%2C%20CommitHash%7D%0A%20%20end%0A%20%20R-%3E%3E%20App%3A%20Request%20for%20hashes%0A"})]),fallback:t(()=>e[0]||(e[0]=[l(" Loading... ")])),_:1})),e[3]||(e[3]=a(`<p>Missing participation at the epoch boundary x/network evaluates participation:</p><ul><li>if validator power‑weighted participation &lt; Quorum (default 2/3) ⇒ return ErrAttestationTimeout and halt new block production;</li><li>validators whose participation &lt; MinParticipation for the entire epoch are auto‑ejected from the attester set via an EditValidator emitted by x/network (their stake remains bonded but they cease to sign until they re‑declare).</li></ul><h4 id="reth-evm-rollup" tabindex="-1">Reth/EVM Rollup <a class="header-anchor" href="#reth-evm-rollup" aria-label="Permalink to &quot;Reth/EVM Rollup&quot;">​</a></h4><ul><li>Stake manager contract holds the validator stake/weight and maps an address to a key. It will emit <code>StakeSnapshot(epoch)</code> events that will be consumed by the consensus client.</li><li>Stake mirror listens for staking snapshot events in order to rebuild the validator set. The proposer will always be the same, we do not support rotation at this time. Once the validator set is rebuilt any changes that are witnessed will be applied to the validator network.</li><li>The EVM will work in the non blocking way. The validators will be able to join and leave as they please with the requirement that they submit attestations of execution in order to provide a soft confirmation within an epoch if they would like a reward for their work.</li></ul><p>Solidity Contract</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>contract StakeManager {</span></span>
<span class="line"><span>    struct Validator { uint96 power; bytes32 edKey; bytes blsKey; }</span></span>
<span class="line"><span>    mapping(address =&gt; Validator) public validators;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    function stake(uint96 amount, bytes32 edKey, bytes calldata blsKey) external;</span></span>
<span class="line"><span>    function unstake(uint96 amount) external;</span></span>
<span class="line"><span>    function slash(address val, uint96 amt) external /* onlyEvidence */;</span></span>
<span class="line"><span>    function snapshot() external returns (bytes32 root); // called by sequencer each epoch</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="quorum-and-liveness" tabindex="-1">Quorum and liveness <a class="header-anchor" href="#quorum-and-liveness" aria-label="Permalink to &quot;Quorum and liveness&quot;">​</a></h3><p>• Quorum rule (per-epoch): <code>signedVotingPower ≥ 2/3 · totalVotingPower</code> • Timers – <code>SubmissionWindow</code> (blocks): max delay after epoch end to include an attestation. – <code>AggregationTimeout</code> (seconds): after window closes; sequencer can advance only if <strong>EmergencyMode</strong> is enabled, otherwise production halts. • Safety vs. liveness — Because verification is local and deterministic, equivocation is impossible: the worst failure mode is not reaching quorum (→ halt) which staking incentives should discourage.</p><h2 id="architecture-interfaces" tabindex="-1">Architecture &amp; Interfaces <a class="header-anchor" href="#architecture-interfaces" aria-label="Permalink to &quot;Architecture &amp; Interfaces&quot;">​</a></h2>`,9)),(i(),n(s,null,{default:t(()=>[r(o,{id:"mermaid-149",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20SQ%5BSequencer%5D%20--%20p2p%20--%3E%20A1%5BAttester%201%5D%0A%20%20%20%20SQ%20--%20p2p%20--%3E%20A2%5BAttester%202%5D%0A%20%20%20%20SQ%20--%20p2p%20--%3E%20A3%5BAttester%20N%5D%0A%20%20%20%20A1%20--%20SubmitSignature%20Tx%20--%3E%20SQ%0A%20%20%20%20A2%20--%20SubmitSignature%20Tx%20--%3E%20SQ%0A%20%20%20%20A3%20--%20SubmitSignature%20Tx%20--%3E%20SQ%0A"})]),fallback:t(()=>e[1]||(e[1]=[l(" Loading... ")])),_:1})),e[4]||(e[4]=a('<h3 id="attester-service" tabindex="-1">Attester service <a class="header-anchor" href="#attester-service" aria-label="Permalink to &quot;Attester service&quot;">​</a></h3><p>• Conn manager — maintains persistent stream to /broadcastBlock and unary client to /SubmitSignature. • Verifier pipeline:</p><ol><li>basic header checks;</li><li>produce signature;</li><li>async submit transaction with signatures</li></ol><h2 id="security-considerations" tabindex="-1">Security considerations <a class="header-anchor" href="#security-considerations" aria-label="Permalink to &quot;Security considerations&quot;">​</a></h2><p>• Double-sign protection — Deterministic bytesToSign makes replay impossible; Ed25519 prevents malleability. • Slashing — Existing Cosmos evidence (MsgEvidence) for missed or duplicate signatures applies unchanged. • Sybil resistance — validator power is staked; no separate token.</p><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><ul><li>Increased code complexity, more to maintain</li></ul><h2 id="future-work" tabindex="-1">Future work <a class="header-anchor" href="#future-work" aria-label="Permalink to &quot;Future work&quot;">​</a></h2><ul><li>Multi-sequencer fail-over — once fast-leader-election is required we can revisit consensus purely for sequencer rotation.</li></ul>',9))])}const y=d(u,[["render",p]]);export{w as __pageData,y as default};
