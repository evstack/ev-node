import{_ as t,c as a,ag as i,o as n}from"./chunks/framework.DlgP5dhN.js";const p=JSON.parse('{"title":"Header and Data Sync","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"Header and Data Sync | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"learn/specs/header-sync.md","filePath":"learn/specs/header-sync.md","lastUpdated":1770122878000}'),r={name:"learn/specs/header-sync.md"};function o(s,e,d,l,h,c){return n(),a("div",null,e[0]||(e[0]=[i('<h1 id="header-and-data-sync" tabindex="-1">Header and Data Sync <a class="header-anchor" href="#header-and-data-sync" aria-label="Permalink to &quot;Header and Data Sync&quot;">​</a></h1><h2 id="abstract" tabindex="-1">Abstract <a class="header-anchor" href="#abstract" aria-label="Permalink to &quot;Abstract&quot;">​</a></h2><p>The nodes in the P2P network sync headers and data using separate sync services that implement the <a href="https://github.com/celestiaorg/go-header" target="_blank" rel="noreferrer">go-header</a> interface. Evolve uses a header/data separation architecture where headers and transaction data are synchronized independently through parallel services. Each sync service consists of several components as listed below.</p><table tabindex="0"><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody><tr><td>store</td><td>a prefixed <a href="https://github.com/ipfs/go-datastore" target="_blank" rel="noreferrer">datastore</a> where synced items are stored (<code>headerSync</code> prefix for headers, <code>dataSync</code> prefix for data)</td></tr><tr><td>subscriber</td><td>a <a href="https://github.com/libp2p/go-libp2p" target="_blank" rel="noreferrer">libp2p</a> node pubsub subscriber for the specific data type</td></tr><tr><td>P2P server</td><td>a server for handling requests between peers in the P2P network</td></tr><tr><td>exchange</td><td>a client that enables sending in/out-bound requests from/to the P2P network</td></tr><tr><td>syncer</td><td>a service for efficient synchronization. When a P2P node falls behind and wants to catch up to the latest network head via P2P network, it can use the syncer.</td></tr></tbody></table><h2 id="details" tabindex="-1">Details <a class="header-anchor" href="#details" aria-label="Permalink to &quot;Details&quot;">​</a></h2><p>Evolve implements two separate sync services:</p><h3 id="header-sync-service" tabindex="-1">Header Sync Service <a class="header-anchor" href="#header-sync-service" aria-label="Permalink to &quot;Header Sync Service&quot;">​</a></h3><ul><li>Synchronizes <code>SignedHeader</code> structures containing block headers with signatures</li><li>Used by all node types (sequencer, full, and light)</li><li>Essential for maintaining the canonical view of the chain</li></ul><h3 id="data-sync-service" tabindex="-1">Data Sync Service <a class="header-anchor" href="#data-sync-service" aria-label="Permalink to &quot;Data Sync Service&quot;">​</a></h3><ul><li>Synchronizes <code>Data</code> structures containing transaction data</li><li>Used only by full nodes and sequencers</li><li>Light nodes do not run this service as they only need headers</li></ul><p>Both services:</p><ul><li>Utilize the generic <code>SyncService[H header.Header[H]]</code> implementation</li><li>Inherit the <code>ConnectionGater</code> from the node&#39;s P2P client for peer management</li><li>Use <code>NodeConfig.BlockTime</code> to determine outdated items during sync</li><li>Operate independently on separate P2P topics and datastores</li></ul><h3 id="consumption-of-sync-services" tabindex="-1">Consumption of Sync Services <a class="header-anchor" href="#consumption-of-sync-services" aria-label="Permalink to &quot;Consumption of Sync Services&quot;">​</a></h3><h4 id="header-sync" tabindex="-1">Header Sync <a class="header-anchor" href="#header-sync" aria-label="Permalink to &quot;Header Sync&quot;">​</a></h4><ul><li>Sequencer nodes publish signed headers to the P2P network after block creation</li><li>Full and light nodes receive and store headers for chain validation</li><li>Headers contain commitments (DataHash) that link to the corresponding data</li></ul><h4 id="data-sync" tabindex="-1">Data Sync <a class="header-anchor" href="#data-sync" aria-label="Permalink to &quot;Data Sync&quot;">​</a></h4><ul><li>Sequencer nodes publish transaction data separately from headers</li><li>Only full nodes receive and store data (light nodes skip this)</li><li>Data is linked to headers through the DataHash commitment</li></ul><h4 id="parallel-broadcasting" tabindex="-1">Parallel Broadcasting <a class="header-anchor" href="#parallel-broadcasting" aria-label="Permalink to &quot;Parallel Broadcasting&quot;">​</a></h4><p>The Executor component (in aggregator nodes) broadcasts headers and data in parallel when publishing blocks:</p><ul><li>Headers are sent through <code>headerBroadcaster</code></li><li>Data is sent through <code>dataBroadcaster</code></li><li>This enables efficient network propagation of both components</li></ul><h2 id="assumptions" tabindex="-1">Assumptions <a class="header-anchor" href="#assumptions" aria-label="Permalink to &quot;Assumptions&quot;">​</a></h2><ul><li>Separate datastores are created with different prefixes: <ul><li>Headers: <code>headerSync</code> prefix on the main datastore</li><li>Data: <code>dataSync</code> prefix on the main datastore</li></ul></li><li>Network IDs are suffixed to distinguish services: <ul><li>Header sync: <code>{network}-headerSync</code></li><li>Data sync: <code>{network}-dataSync</code></li></ul></li><li>Chain IDs for pubsub topics are also separated: <ul><li>Headers: <code>{chainID}-headerSync</code> creates topic like <code>/gm-headerSync/header-sub/v0.0.1</code></li><li>Data: <code>{chainID}-dataSync</code> creates topic like <code>/gm-dataSync/header-sub/v0.0.1</code></li></ul></li><li>Both stores must contain at least one item before the syncer starts: <ul><li>On first boot, the services fetch the configured genesis height from peers</li><li>On restart, each store reuses its latest item to derive the initial height requested from peers</li></ul></li><li>Sync services work only when connected to P2P network via <code>P2PConfig.Seeds</code></li><li>Node context is passed to all components for graceful shutdown</li><li>Headers and data are linked through DataHash but synced independently</li></ul><h2 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h2><p>The sync service implementation can be found in <a href="https://github.com/evstack/ev-node/blob/main/pkg/sync/sync_service.go" target="_blank" rel="noreferrer">pkg/sync/sync_service.go</a>. The generic <code>SyncService[H header.Header[H]]</code> is instantiated as:</p><ul><li><code>HeaderSyncService</code> for syncing <code>*types.SignedHeader</code></li><li><code>DataSyncService</code> for syncing <code>*types.Data</code></li></ul><p>Full nodes create and start both services, while light nodes only start the header sync service. The services are created in <a href="https://github.com/evstack/ev-node/blob/main/node/full.go" target="_blank" rel="noreferrer">full</a> and <a href="https://github.com/evstack/ev-node/blob/main/node/light.go" target="_blank" rel="noreferrer">light</a> node implementations.</p><p>The block components integrate with both services through:</p><ul><li>The Syncer component&#39;s P2PHandler retrieves headers and data from P2P</li><li>The Executor component publishes headers and data through broadcast channels</li><li>Separate stores and channels manage header and data synchronization</li></ul><h2 id="da-height-hints" tabindex="-1">DA Height Hints <a class="header-anchor" href="#da-height-hints" aria-label="Permalink to &quot;DA Height Hints&quot;">​</a></h2><p>DA Height Hints (DAHint) provide an optimization for P2P synchronization by indicating which DA layer height contains a block&#39;s header or data. This allows syncing nodes to fetch missing DA data directly instead of performing sequential DA scanning.</p><h3 id="naming-considerations" tabindex="-1">Naming Considerations <a class="header-anchor" href="#naming-considerations" aria-label="Permalink to &quot;Naming Considerations&quot;">​</a></h3><p>The naming convention follows this pattern:</p><table tabindex="0"><thead><tr><th>Name</th><th>Usage</th></tr></thead><tbody><tr><td><code>DAHeightHint</code></td><td>Internal struct field storing the hint value</td></tr><tr><td><code>DAHint()</code></td><td>Getter method returning the DA height hint</td></tr><tr><td><code>SetDAHint()</code></td><td>Setter method for the DA height hint</td></tr><tr><td><code>P2PSignedHeader</code></td><td>Wrapper around <code>SignedHeader</code> that includes <code>DAHeightHint</code></td></tr><tr><td><code>P2PData</code></td><td>Wrapper around <code>Data</code> that includes <code>DAHeightHint</code></td></tr></tbody></table><p>The term &quot;hint&quot; is used deliberately because:</p><ol><li><strong>It&#39;s advisory, not authoritative</strong>: The hint suggests where to find data on the DA layer, but the authoritative source is always the DA layer itself</li><li><strong>It may be absent</strong>: Hints are only populated during certain sync scenarios (see below)</li><li><strong>It optimizes but doesn&#39;t replace</strong>: Nodes can still function without hints by scanning the DA layer sequentially</li></ol><h3 id="when-dahints-are-populated" tabindex="-1">When DAHints Are Populated <a class="header-anchor" href="#when-dahints-are-populated" aria-label="Permalink to &quot;When DAHints Are Populated&quot;">​</a></h3><p>DAHints are <strong>only populated when a node catches up from P2P</strong> and is not yet synced to the head. When a node is already synced to the head:</p><ul><li>The executor broadcasts headers/data immediately after block creation</li><li>At this point, DA submission has not occurred yet (it happens later in the flow)</li><li>Therefore, the broadcasted P2P messages do not contain DA hints</li></ul><p>This means:</p><ul><li><strong>Syncing nodes</strong> (catching up): Receive headers/data with DA hints populated</li><li><strong>Synced nodes</strong> (at head): Receive headers/data without DA hints</li></ul><p>The DA hints are set by the DA submitter after successful inclusion on the DA layer and stored for later P2P propagation to syncing peers.</p><h3 id="implementation-details" tabindex="-1">Implementation Details <a class="header-anchor" href="#implementation-details" aria-label="Permalink to &quot;Implementation Details&quot;">​</a></h3><p>The P2P wrapper types (<code>P2PSignedHeader</code> and <code>P2PData</code>) extend the base types with an optional <code>DAHeightHint</code> field:</p><ul><li>Uses protobuf optional fields (<code>optional uint64 da_height_hint</code>) for backward compatibility</li><li>Old nodes can still unmarshal new messages (the hint field is simply ignored)</li><li>New nodes can unmarshal old messages (the hint field defaults to zero/absent)</li></ul><p>The hint flow:</p><ol><li><strong>Set by the DA Submitter</strong> when headers/data are successfully included on the DA layer</li><li><strong>Stored in the P2P store</strong> alongside the header/data</li><li><strong>Propagated via P2P</strong> when syncing nodes request blocks</li><li><strong>Queued as priority</strong> by the Syncer&#39;s DA retriever when received via P2P</li><li><strong>Fetched before sequential heights</strong> - priority heights take precedence over normal DA scanning</li></ol><h3 id="priority-queue-mechanism" tabindex="-1">Priority Queue Mechanism <a class="header-anchor" href="#priority-queue-mechanism" aria-label="Permalink to &quot;Priority Queue Mechanism&quot;">​</a></h3><p>When a P2P event arrives with a DA height hint, the hint is queued as a priority height in the DA retriever. The <code>fetchDAUntilCaughtUp</code> loop checks for priority heights first:</p><ol><li>If priority heights are queued, pop and fetch the lowest one first</li><li>If no priority heights, continue sequential DA fetching (form last known da height)</li><li>Priority heights are sorted ascending to process lower heights first</li><li>Already-processed priority heights are tracked to avoid duplicate fetches</li></ol><p>This ensures that when syncing from P2P, the node can immediately fetch the DA data for blocks it receives, rather than waiting for sequential scanning to reach that height.</p><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><p>[1] <a href="https://github.com/evstack/ev-node/blob/main/pkg/sync/sync_service.go" target="_blank" rel="noreferrer">Header Sync</a></p><p>[2] <a href="https://github.com/evstack/ev-node/blob/main/node/full.go" target="_blank" rel="noreferrer">Full Node</a></p><p>[3] <a href="https://github.com/evstack/ev-node/blob/main/node/light.go" target="_blank" rel="noreferrer">Light Node</a></p><p>[4] <a href="https://github.com/celestiaorg/go-header" target="_blank" rel="noreferrer">go-header</a></p>',55)]))}const g=t(r,[["render",o]]);export{p as __pageData,g as default};
