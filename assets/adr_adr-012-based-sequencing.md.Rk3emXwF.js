import{_ as n,c as o,ag as i,b as r,w as a,af as l,B as c,o as s,G as h,a as d}from"./chunks/framework.DlgP5dhN.js";const y=JSON.parse('{"title":"ADR 012: Based Sequencing","description":"","frontmatter":{"head":[["meta",{"name":"og:title","content":"ADR 012: Based Sequencing | Evolve"},{"name":"og:description","content":false}]]},"headers":[],"relativePath":"adr/adr-012-based-sequencing.md","filePath":"adr/adr-012-based-sequencing.md","lastUpdated":1764781917000}'),p={name:"adr/adr-012-based-sequencing.md"};function u(g,e,k,m,b,f){const t=c("Mermaid");return s(),o("div",null,[e[1]||(e[1]=i('<h1 id="adr-012-based-sequencing" tabindex="-1">ADR 012: Based Sequencing <a class="header-anchor" href="#adr-012-based-sequencing" aria-label="Permalink to &quot;ADR 012: Based Sequencing&quot;">​</a></h1><h2 id="changelog" tabindex="-1">Changelog <a class="header-anchor" href="#changelog" aria-label="Permalink to &quot;Changelog&quot;">​</a></h2><ul><li>2025-04-09: Initial draft</li><li>2025-04-09: Added optional UX optimization where full nodes can relay user transactions to base layer</li><li>2025-04-09: Added rationale for VerifyBatch utility in a based setup</li><li>2025-04-10: Added Relaying Costs and Fee Compensation via EVM</li><li>2025-11-27: Updated to reflect actual implementation with epoch-based forced inclusion</li></ul><h2 id="context" tabindex="-1">Context <a class="header-anchor" href="#context" aria-label="Permalink to &quot;Context&quot;">​</a></h2><p>Most chains today rely on single sequencers to form batches of user transactions, despite the availability of base layers (like Celestia) that provide data availability and canonical ordering guarantees. A single sequencer introduces liveness and censorship risks, as well as complexity in proposer election, fault tolerance, and bridge security.</p><p>Based sequencing eliminates this reliance by having the base layer determine transaction ordering. This ADR describes the <strong>epoch-based forced inclusion</strong> implementation where <strong>every full node acts as its own proposer</strong> by independently:</p><ul><li>Reading forced inclusion transactions from the base layer at epoch boundaries</li><li>Applying deterministic batching rules</li><li>Executing transactions to compute state updates</li></ul><p>This approach ensures consistency, removes the need for trusted intermediaries, and improves decentralization and resilience.</p><h2 id="alternative-approaches" tabindex="-1">Alternative Approaches <a class="header-anchor" href="#alternative-approaches" aria-label="Permalink to &quot;Alternative Approaches&quot;">​</a></h2><h3 id="single-sequencer" tabindex="-1">Single Sequencer <a class="header-anchor" href="#single-sequencer" aria-label="Permalink to &quot;Single Sequencer&quot;">​</a></h3><ul><li>A designated sequencer collects transactions and publishes them to the base layer.</li><li>Simpler for UX and latency control, but introduces centralization and failure points.</li></ul><h3 id="leader-elected-proposer-e-g-bft-committee-or-rotating-proposer" tabindex="-1">Leader-Elected Proposer (e.g., BFT committee or rotating proposer) <a class="header-anchor" href="#leader-elected-proposer-e-g-bft-committee-or-rotating-proposer" aria-label="Permalink to &quot;Leader-Elected Proposer (e.g., BFT committee or rotating proposer)&quot;">​</a></h3><ul><li>Some nodes are elected to act as proposers for efficiency.</li><li>Still introduces trust assumptions, coordination complexity, and MEV-related risks.</li></ul><h3 id="continuous-da-polling" tabindex="-1">Continuous DA Polling <a class="header-anchor" href="#continuous-da-polling" aria-label="Permalink to &quot;Continuous DA Polling&quot;">​</a></h3><ul><li>Full nodes continuously poll DA and form batches based on size thresholds.</li><li>More complex coordination and can lead to inconsistent batch boundaries across nodes.</li></ul><p>The epoch-based approach provides deterministic batch boundaries while minimizing DA queries and ensuring all honest nodes derive identical blocks.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><p>We adopt a based sequencing model where every full node in the network acts as its own proposer using an epoch-based forced inclusion mechanism:</p><h3 id="core-principles" tabindex="-1">Core Principles <a class="header-anchor" href="#core-principles" aria-label="Permalink to &quot;Core Principles&quot;">​</a></h3><ol><li><strong>Epoch Boundaries</strong>: Transactions are retrieved from DA in epochs defined by <code>DAEpochForcedInclusion</code></li><li><strong>Deterministic Batch Formation</strong>: All nodes apply the same rules to form batches from queued transactions</li><li><strong>MaxBytes Enforcement</strong>: Individual blocks respect a maximum byte limit (2MB default)</li><li><strong>Transaction Smoothing</strong>: Large transaction sets can be smoothed across multiple blocks within an epoch</li><li><strong>No Trusted Sequencer</strong>: All ordering comes from the base layer</li></ol><h3 id="sequencing-model" tabindex="-1">Sequencing Model <a class="header-anchor" href="#sequencing-model" aria-label="Permalink to &quot;Sequencing Model&quot;">​</a></h3><p>The <code>BasedSequencer</code> implementation:</p><ul><li><strong>Only retrieves transactions from DA</strong> via forced inclusion namespace</li><li><strong>Ignores transactions submitted via <code>SubmitBatchTxs</code></strong> (no mempool)</li><li><strong>Fetches at epoch boundaries</strong> to minimize DA queries</li><li><strong>Queues transactions</strong> and creates batches respecting <code>MaxBytes</code></li><li><strong>Validates blob sizes</strong> against absolute maximum to prevent oversized submissions</li></ul><h3 id="transaction-flow" tabindex="-1">Transaction Flow <a class="header-anchor" href="#transaction-flow" aria-label="Permalink to &quot;Transaction Flow&quot;">​</a></h3>',24)),(s(),r(l,null,{default:a(()=>[h(t,{id:"mermaid-185",class:"mermaid",graph:"sequenceDiagram%0A%20%20%20%20participant%20User%0A%20%20%20%20participant%20DA%20as%20Base%20Layer%20(Celestia)%0A%20%20%20%20participant%20NodeA%20as%20Full%20Node%20A%0A%20%20%20%20participant%20NodeB%20as%20Full%20Node%20B%0A%20%20%20%20participant%20ExecA%20as%20Execution%20Engine%20A%0A%20%20%20%20participant%20ExecB%20as%20Execution%20Engine%20B%0A%0A%20%20%20%20Note%20over%20User%3A%20User%20posts%20transaction%20to%20DA%3Cbr%2F%3Eforced%20inclusion%20namespace%0A%0A%20%20%20%20User-%3E%3EDA%3A%20Submit%20blob%20to%20forced%20inclusion%20namespace%0A%0A%20%20%20%20Note%20over%20NodeA%2CNodeB%3A%20At%20epoch%20start%20(e.g.%2C%20DA%20height%20100%2C%20110%2C%20120...)%0A%0A%20%20%20%20NodeA-%3E%3EDA%3A%20RetrieveForcedIncludedTxs(epochStart)%0A%20%20%20%20NodeB-%3E%3EDA%3A%20RetrieveForcedIncludedTxs(epochStart)%0A%0A%20%20%20%20DA--%3E%3ENodeA%3A%20Txs%20from%20epoch%20%5B100-109%5D%0A%20%20%20%20DA--%3E%3ENodeB%3A%20Txs%20from%20epoch%20%5B100-109%5D%0A%0A%20%20%20%20Note%20over%20NodeA%2CNodeB%3A%20Queue%20transactions%20and%20create%20batches%3Cbr%2F%3Erespecting%20MaxBytes%0A%0A%20%20%20%20NodeA-%3E%3ENodeA%3A%20createBatchFromQueue(MaxBytes)%0A%20%20%20%20NodeB-%3E%3ENodeB%3A%20createBatchFromQueue(MaxBytes)%0A%0A%20%20%20%20NodeA-%3E%3EExecA%3A%20ExecuteTxs(batch)%0A%20%20%20%20NodeB-%3E%3EExecB%3A%20ExecuteTxs(batch)%0A%0A%20%20%20%20ExecA--%3E%3ENodeA%3A%20State%20root%0A%20%20%20%20ExecB--%3E%3ENodeB%3A%20State%20root%0A%0A%20%20%20%20Note%20over%20NodeA%2CNodeB%3A%20Both%20nodes%20produce%20identical%20blocks%0A"})]),fallback:a(()=>e[0]||(e[0]=[d(" Loading... ")])),_:1})),e[2]||(e[2]=i(`<h2 id="detailed-design" tabindex="-1">Detailed Design <a class="header-anchor" href="#detailed-design" aria-label="Permalink to &quot;Detailed Design&quot;">​</a></h2><h3 id="epoch-based-retrieval" tabindex="-1">Epoch-Based Retrieval <a class="header-anchor" href="#epoch-based-retrieval" aria-label="Permalink to &quot;Epoch-Based Retrieval&quot;">​</a></h3><p><strong>Epoch Calculation</strong>:</p><ul><li>Epoch number: <code>((daHeight - daStartHeight) / daEpochSize) + 1</code></li><li>Epoch boundaries: <code>[start, end]</code> where transactions must be included</li></ul><p><strong>Example with <code>DAEpochForcedInclusion = 10</code></strong>:</p><ul><li>DA heights 100-109 = Epoch 1</li><li>DA heights 110-119 = Epoch 2</li><li>DA heights 120-129 = Epoch 3</li></ul><p><strong>Retrieval Logic</strong> (<code>ForcedInclusionRetriever</code>):</p><ol><li>Check if DA height is at epoch start</li><li>If not at epoch start, return empty transaction set</li><li>If at epoch start, fetch all blobs from forced inclusion namespace for entire epoch</li><li>Return <code>ForcedInclusionEvent</code> with transactions and DA height range</li></ol><h3 id="batch-formation" tabindex="-1">Batch Formation <a class="header-anchor" href="#batch-formation" aria-label="Permalink to &quot;Batch Formation&quot;">​</a></h3><p><strong>BasedSequencer Queue Management</strong>:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// On GetNextBatch:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Retrieve forced inclusion transactions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current epoch</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Validate blob sizes (skip oversized blobs)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Add valid transactions to internal queue</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Create batch from queue respecting MaxBytes</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Return batch (may be partial </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> queue exceeds MaxBytes)</span></span></code></pre></div><p><strong>Batch Creation</strong> (<code>createBatchFromQueue</code>):</p><ul><li>Iterate through queued transactions</li><li>Accumulate until <code>totalBytes + txSize &gt; MaxBytes</code></li><li>Stop at limit and preserve remaining transactions for next block</li><li>Clear queue when all transactions consumed</li></ul><h3 id="block-production" tabindex="-1">Block Production <a class="header-anchor" href="#block-production" aria-label="Permalink to &quot;Block Production&quot;">​</a></h3><p><strong>Executor Flow</strong> (<code>block/internal/executing/executor.go</code>):</p><ol><li><strong>Retrieve Batch</strong>: Call <code>sequencer.GetNextBatch(MaxBytes: 2MB)</code></li><li><strong>Handle Empty Batch</strong>: Skip block production if no transactions</li><li><strong>Create Block</strong>: Form block header and data with batch transactions</li><li><strong>Execute</strong>: Apply transactions via execution engine</li><li><strong>Update State</strong>: Store DA height from sequencer in state</li><li><strong>Sign Header</strong>: Based sequencer returns empty signature</li><li><strong>Persist</strong>: Save block to store</li><li><strong>Broadcast</strong>: Propagate header and data to P2P network</li></ol><h3 id="transaction-smoothing" tabindex="-1">Transaction Smoothing <a class="header-anchor" href="#transaction-smoothing" aria-label="Permalink to &quot;Transaction Smoothing&quot;">​</a></h3><p>When forced inclusion transactions exceed <code>MaxBytes</code>:</p><p><strong>Block 1</strong>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Epoch [100-109] contains 3MB of transactions</span></span>
<span class="line"><span>Block at DA height 100: 2MB (partial)</span></span>
<span class="line"><span>Remaining in queue: 1MB</span></span></code></pre></div><p><strong>Block 2</strong>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Block at DA height 101: 1MB (remainder) + new regular txs</span></span>
<span class="line"><span>Queue cleared</span></span></code></pre></div><p>This ensures all epoch transactions are eventually included while respecting block size limits.</p><h3 id="forced-inclusion-verification" tabindex="-1">Forced Inclusion Verification <a class="header-anchor" href="#forced-inclusion-verification" aria-label="Permalink to &quot;Forced Inclusion Verification&quot;">​</a></h3><p>Full nodes verify that batches include all required forced inclusion transactions via <code>Syncer.verifyForcedInclusionTxs</code>:</p><ol><li>Retrieve forced inclusion transactions for current DA height</li><li>Check all forced txs are present in block</li><li>Allow deferral within epoch boundaries</li><li>Reject blocks that: <ul><li>Censor forced inclusion transactions after epoch end</li><li>Skip forced transactions without valid reason</li></ul></li></ol><h3 id="data-structures" tabindex="-1">Data Structures <a class="header-anchor" href="#data-structures" aria-label="Permalink to &quot;Data Structures&quot;">​</a></h3><p><strong>ForcedInclusionEvent</strong>:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForcedInclusionEvent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    StartDaHeight </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Epoch start DA height</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    EndDaHeight   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint64</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Last processed DA height in epoch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Txs           [][]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // All transactions from epoch</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>BasedSequencer State</strong>:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BasedSequencer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    daHeight    </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">atomic</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Uint64</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Current DA height</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    txQueue     [][]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">byte</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // Queued transactions awaiting inclusion</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="configuration" tabindex="-1">Configuration <a class="header-anchor" href="#configuration" aria-label="Permalink to &quot;Configuration&quot;">​</a></h3><p><strong>Genesis Configuration</strong>:</p><ul><li><code>DAStartHeight</code>: Starting DA height for the chain</li><li><code>DAEpochForcedInclusion</code>: Number of DA blocks per epoch (e.g., 10)</li></ul><p><strong>Constants</strong>:</p><ul><li><code>DefaultMaxBlobSize</code>: 2MB per batch/block</li><li>Enforced both at submission and retrieval</li></ul><h3 id="systems-affected" tabindex="-1">Systems Affected <a class="header-anchor" href="#systems-affected" aria-label="Permalink to &quot;Systems Affected&quot;">​</a></h3><ul><li><strong>BasedSequencer</strong>: Implements epoch-based transaction retrieval</li><li><strong>ForcedInclusionRetriever</strong>: Fetches transactions from DA at epochs</li><li><strong>Executor</strong>: Drives block production using sequencer batches</li><li><strong>Syncer</strong>: Verifies forced inclusion compliance</li><li><strong>DA Client</strong>: Must support forced inclusion namespace</li></ul><h3 id="apis" tabindex="-1">APIs <a class="header-anchor" href="#apis" aria-label="Permalink to &quot;APIs&quot;">​</a></h3><p><strong>Sequencer Interface</strong>:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Returns empty response - based sequencer ignores submissions</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SubmitBatchTxs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, req) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SubmitBatchTxsResponse, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retrieves next batch from forced inclusion queue</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GetNextBatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, req) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GetNextBatchResponse, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Always returns true for based sequencer</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">VerifyBatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, req) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VerifyBatchResponse, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Forced Inclusion Retrieval</strong>:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Retrieves forced inclusion txs at DA height (epoch start)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RetrieveForcedIncludedTxs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, daHeight) (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ForcedInclusionEvent, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="block-time-characteristics" tabindex="-1">Block Time Characteristics <a class="header-anchor" href="#block-time-characteristics" aria-label="Permalink to &quot;Block Time Characteristics&quot;">​</a></h3><ul><li><strong>Block time is a function of DA layer block time</strong></li><li>With <code>DAEpochForcedInclusion = 10</code> and Celestia ~12s block time: <ul><li>Minimum block time: ~12s (if transactions present)</li><li>Maximum epoch duration: ~120s (10 blocks)</li></ul></li><li><strong>Lazy mode has no effect</strong> - based sequencing inherently follows DA timing</li><li><strong>No headers are published to DA</strong> - only forced inclusion blobs</li></ul><h3 id="security-considerations" tabindex="-1">Security Considerations <a class="header-anchor" href="#security-considerations" aria-label="Permalink to &quot;Security Considerations&quot;">​</a></h3><p><strong>Trust Model</strong>:</p><ul><li>No trusted sequencer required</li><li>All nodes derive identical state from DA</li><li>Invalid blocks are automatically rejected by execution rules</li></ul><p><strong>Attack Vectors</strong>:</p><ul><li>Invalid State: Rejected by execution engine during <code>ExecuteTxs</code></li><li>Blob Spam: Limited by DA namespace fees and size validation</li><li>Incorrect Batch: Each node independently derives batches, inconsistent nodes fall out of sync</li></ul><h3 id="efficiency" tabindex="-1">Efficiency <a class="header-anchor" href="#efficiency" aria-label="Permalink to &quot;Efficiency&quot;">​</a></h3><ul><li>Minimal DA Queries: Only fetch at epoch boundaries</li><li>Bounded Latency: Epoch duration provides upper bound</li><li>Transaction Queuing: Smooth large batches across multiple blocks</li></ul><h2 id="status" tabindex="-1">Status <a class="header-anchor" href="#status" aria-label="Permalink to &quot;Status&quot;">​</a></h2><p>Implemented</p><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><h3 id="positive" tabindex="-1">Positive <a class="header-anchor" href="#positive" aria-label="Permalink to &quot;Positive&quot;">​</a></h3><ul><li><strong>Eliminates single sequencer dependency</strong> - fully decentralized ordering</li><li><strong>Deterministic consensus</strong> - all nodes converge on same state</li><li><strong>Censorship resistance</strong> - forced inclusion verified by all nodes</li><li><strong>Simplified architecture</strong> - no proposer election or coordination</li><li><strong>Economic sustainability</strong> - fee recipient mechanism enables relay compensation</li></ul><h3 id="negative" tabindex="-1">Negative <a class="header-anchor" href="#negative" aria-label="Permalink to &quot;Negative&quot;">​</a></h3><ul><li><strong>Block time tied to DA layer</strong> - cannot be independently configured</li><li><strong>Minimum latency</strong> - at least one DA block time</li><li><strong>Epoch-based batching</strong> - cannot include transactions mid-epoch</li></ul><h3 id="neutral" tabindex="-1">Neutral <a class="header-anchor" href="#neutral" aria-label="Permalink to &quot;Neutral&quot;">​</a></h3><ul><li><strong>No mempool in based sequencer</strong> - transactions only via forced inclusion</li><li><strong>Queue management required</strong> - full nodes maintain transaction queues</li><li><strong>DA namespace dependency</strong> - requires forced inclusion namespace support</li></ul><h2 id="future-enhancements" tabindex="-1">Future Enhancements <a class="header-anchor" href="#future-enhancements" aria-label="Permalink to &quot;Future Enhancements&quot;">​</a></h2><ol><li><strong>Transaction Relaying</strong>: Implement full node RPC endpoints to accept and relay user transactions to DA</li><li><strong>Dynamic Epochs</strong>: Adjust epoch size based on transaction volume or network conditions</li><li><strong>Priority Mechanisms</strong>: Support application-specific transaction ordering within epochs</li><li><strong>Light Client Integration</strong>: Implement header verification without full re-execution</li><li><strong>Cross-Chain Inclusion</strong>: Enable forced inclusion from multiple DA layers</li></ol><h2 id="references" tabindex="-1">References <a class="header-anchor" href="#references" aria-label="Permalink to &quot;References&quot;">​</a></h2><ul><li><a href="https://ethresear.ch/t/based-rollups-superpowers-from-l1-sequencing/15016" target="_blank" rel="noreferrer">EthResearch: Based Rollups</a></li><li><a href="https://taiko.mirror.xyz/7dfMydX1FqEx9_sOvhRt3V8hJksKSIWjzhCVu7FyMZU" target="_blank" rel="noreferrer">Taiko: Based Sequencing</a></li><li><a href="https://www.surge.wtf/" target="_blank" rel="noreferrer">Surge Rollup</a></li><li><a href="https://www.spire.dev/" target="_blank" rel="noreferrer">Spire</a></li><li><a href="https://www.puffer.fi/unifi" target="_blank" rel="noreferrer">Puffer UniFi</a></li></ul>`,65))])}const A=n(p,[["render",u]]);export{y as __pageData,A as default};
