package notifier

import (
	"sync"
	"time"

	"github.com/rs/zerolog"
)

// EventType identifies whether a notification refers to a header or block data artifact.
type EventType string

const (
	// EventTypeHeader marks header events.
	EventTypeHeader EventType = "header"
	// EventTypeData marks block data events.
	EventTypeData EventType = "data"
)

// EventSource describes where the artifact originated from.
type EventSource string

const (
	// SourceUnknown marks an event where the origin could not be determined.
	SourceUnknown EventSource = "unknown"
	// SourceLocal marks events generated by the local node (executor, bootstrap, DA replay).
	SourceLocal EventSource = "local"
	// SourceP2P marks events retrieved from the P2P network.
	SourceP2P EventSource = "p2p"
)

// Event carries metadata about a stored artifact height.
type Event struct {
	Type      EventType
	Height    uint64
	Hash      string
	Source    EventSource
	Timestamp time.Time
}

// Subscription wraps a read-only event channel with an unsubscribe function.
type Subscription struct {
	C        <-chan Event
	cancel   func()
	once     sync.Once
	notifier *Notifier
	id       uint64
}

// Cancel stops delivery for this subscription. It is safe to call multiple times.
func (s *Subscription) Cancel() {
	if s == nil {
		return
	}
	s.once.Do(func() {
		if s.cancel != nil {
			s.cancel()
		}
	})
}

// Notifier fan-outs store events to subscribers.
type Notifier struct {
	logger zerolog.Logger
	size   int

	mu   sync.RWMutex
	subs map[uint64]chan Event
	next uint64
}

// New creates a notifier with the given buffer size per subscriber.
func New(bufferSize int, logger zerolog.Logger) *Notifier {
	if bufferSize <= 0 {
		bufferSize = 1
	}
	return &Notifier{
		logger: logger,
		size:   bufferSize,
		subs:   make(map[uint64]chan Event),
	}
}

// Publish fan-outs the event to all subscribers using best-effort delivery.
// Returns true if at least one subscriber received the event without dropping it.
func (n *Notifier) Publish(evt Event) bool {
	n.mu.RLock()
	defer n.mu.RUnlock()

	if len(n.subs) == 0 {
		return false
	}

	delivered := false
	for id, ch := range n.subs {
		select {
		case ch <- evt:
			delivered = true
		default:
			n.logger.Debug().
				Str("type", string(evt.Type)).
				Uint64("height", evt.Height).
				Str("source", string(evt.Source)).
				Uint64("subscriber_id", id).
				Msg("dropping event: subscriber channel full")
		}
	}

	return delivered
}

// Subscribe registers a new subscriber and returns a subscription handle.
func (n *Notifier) Subscribe() *Subscription {
	n.mu.Lock()
	defer n.mu.Unlock()

	id := n.next
	n.next++

	ch := make(chan Event, n.size)
	n.subs[id] = ch

	sub := &Subscription{
		C:        ch,
		notifier: n,
		id:       id,
	}
	sub.cancel = func() {
		n.mu.Lock()
		defer n.mu.Unlock()
		if existing, ok := n.subs[id]; ok {
			delete(n.subs, id)
			close(existing)
		}
	}

	return sub
}

// SubscriberCount reports the current number of active subscribers.
func (n *Notifier) SubscriberCount() int {
	n.mu.RLock()
	defer n.mu.RUnlock()
	return len(n.subs)
}
